

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>geonat.models &mdash; GeoNAT 0.8 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> GeoNAT
          

          
          </a>

          
            
            
              <div class="version">
                0.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_1.html">Tutorial 1: The first synthetic station</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#building-a-model-collection">Building a Model collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#creating-timeseries-objects">Creating Timeseries objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#fitting-the-models">Fitting the models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#plotting-the-fit-and-residuals">Plotting the fit and residuals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_2.html">Tutorial 2: Advanced Models and Fitting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#creating-more-complex-synthetic-data">Creating more complex synthetic data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#spline-models-for-transients">Spline models for transients</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#building-a-network">Building a Network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#fitting-an-entire-network">Fitting an entire network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#advanced-plotting">Advanced plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#repeat-with-l2-regularization">Repeat with L2 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#repeat-with-l1-regularization">Repeat with L1 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#adding-reweighting-iterations">Adding reweighting iterations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#comparing-specific-parameters">Comparing specific parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_3.html">Tutorial 3: Incorporating Spatial Coherence</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#preparations">Preparations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#dreaming-up-a-network">Dreaming up a network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#fantasizing-data">Fantasizing data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#removing-the-common-mode-error">Removing the Common Mode Error</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#fitting-the-data-using-reweighted-l1-regularization">Fitting the data using reweighted L1 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#fitting-the-data-using-a-spatially-aware-l1-reweighting">Fitting the data using a spatially-aware L1 reweighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#finding-unmodeled-jumps">Finding unmodeled jumps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#statistics-of-spatial-reweighting">Statistics of spatial reweighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#model-parameter-correlations">Model parameter correlations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#transient-visualization-with-worm-plots">Transient visualization with worm plots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_4.html">Tutorial 4: The use and estimation of covariance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#making-a-noisy-network">Making a noisy network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#fitting-the-models-with-the-spatial-l0-solver">Fitting the models with the spatial L0 solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#quality-of-the-fits">Quality of the fits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#correlation-of-parameters">Correlation of parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#simple-linear-regression-with-restricted-spline-set">Simple linear regression with restricted spline set</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#empirical-covariance-estimation">Empirical covariance estimation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/example_1.html">Example 1: Long Valley Caldera Transient Motions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#preparations">Preparations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#getting-data">Getting data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#building-the-network">Building the network</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#cleaning-the-timeseries">Cleaning the timeseries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#outlier-and-cme-removal">Outlier and CME removal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#first-pass-major-steps-and-noisy-periods">First pass: major steps and noisy periods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#second-pass-minor-catalog-based-steps">Second pass: minor, catalog-based steps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#model-parameter-estimation">Model parameter estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#comparison-of-secular-velocities">Comparison of secular velocities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#final-considerations">Final considerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../geonat.html">GeoNAT</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/compiled.html">Compiled</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/compiled.html#maskedmedfilt2d">maskedmedfilt2d</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/compiled.html#source-code">Source Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/config.html">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/earthquakes.html">Earthquakes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/models.html">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/models.html#model-parent-class">Model (Parent Class)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/models.html#model-collection">Model Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/models.html#basic-models">Basic Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#arctangent">Arctangent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#exponential">Exponential</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#logarithmic">Logarithmic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#polynomial">Polynomial</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#step">Step</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#sinusoidal">Sinusoidal</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/models.html#spline-models">Spline Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#bspline">BSpline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#ispline">ISpline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/models.html#splineset">SplineSet</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/network.html">Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/processing.html">Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/processing.html#unwrap-dict-and-ts">unwrap_dict_and_ts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/processing.html#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/processing.html#clean">clean</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/processing.html#common-mode">common_mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/processing.html#median">median</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/processing.html#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/processing.html#stepdetector">StepDetector</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/solvers.html">Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/solvers.html#local-solver-functions">Local Solver Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#lasso-regression">lasso_regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#linear-regression">linear_regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#ridge-regression">ridge_regression</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/solvers.html#global-solver-classes">Global Solver Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#spatialsolver">SpatialSolver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/solvers.html#solution-object">Solution Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/solvers.html#reweighting-functions">Reweighting Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#reweightingfunction">ReweightingFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#inversereweighting">InverseReweighting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#inversesquaredreweighting">InverseSquaredReweighting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/solvers.html#logarithmicreweighting">LogarithmicReweighting</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/station.html">Station</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/timeseries.html">Timeseries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/timeseries.html#timeseries-parent-class">Timeseries (Parent Class)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/timeseries.html#specialized-classes">Specialized Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/timeseries.html#gipsytimeseries">GipsyTimeseries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/timeseries.html#unrtimeseries">UNRTimeseries</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../geonat/tools.html">Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/tools.html#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#parallelize">parallelize</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#tvec-to-numpycol">tvec_to_numpycol</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#create-powerlaw-noise">create_powerlaw_noise</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#parse-maintenance-table">parse_maintenance_table</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#weighted-median">weighted_median</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#download-unr-data">download_unr_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#parse-unr-steps">parse_unr_steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#get-cov-dims">get_cov_dims</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#make-cov-index-map">make_cov_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#get-cov-indices">get_cov_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#full-cov-mat-to-columns">full_cov_mat_to_columns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#block-permutation">block_permutation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#cov2corr">cov2corr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../geonat/tools.html#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#rinexdataholding">RINEXDataHolding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#timedelta">Timedelta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../geonat/tools.html#click">Click</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GeoNAT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>geonat.models</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for geonat.models</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains all models that can be used to fit the data</span>
<span class="sd">or generate synthetic timeseries.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span><span class="p">,</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">cmcrameri</span> <span class="kn">import</span> <span class="n">cm</span> <span class="k">as</span> <span class="n">scm</span>

<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">tvec_to_numpycol</span><span class="p">,</span> <span class="n">Timedelta</span><span class="p">,</span> <span class="n">full_cov_mat_to_columns</span><span class="p">,</span> <span class="n">cov2corr</span>


<div class="viewcode-block" id="Model"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model">[docs]</a><span class="k">class</span> <span class="nc">Model</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for models.</span>

<span class="sd">    The class implements some common methods as to how one interacts with models, with</span>
<span class="sd">    the goal that subclasses of it can focus on as few details as possible.</span>

<span class="sd">    A model, generally speaking, is defined by parameters (and optionally their</span>
<span class="sd">    covariance), and can be evaluated given a series of timestamps. Most models will</span>
<span class="sd">    make use of the :attr:`~time_unit` and :attr:`~t_reference` attributes to relate</span>
<span class="sd">    time series into data space. Solvers can check the :attr:`~regularize` attribute</span>
<span class="sd">    to regularize the model during fitting.</span>

<span class="sd">    Models are usually linear (but can be overriden in subclasses), and adhere to the</span>
<span class="sd">    nomenclature</span>

<span class="sd">    .. math:: \mathbf{G}(\mathbf{t}) \cdot \mathbf{m} = \mathbf{d}</span>

<span class="sd">    where :math:`\mathbf{G}` is the mapping matrix, :math:`\mathbf{t}` is the time</span>
<span class="sd">    vector, :math:`\mathbf{m}` are the model parameters, and :math:`\mathbf{d}` are</span>
<span class="sd">    the observations.</span>

<span class="sd">    Models are always active by default, i.e. they implement a certain functional form</span>
<span class="sd">    that can be evaluated at any time. By setting the :attr:`~t_start` and :attr:`~t_end`</span>
<span class="sd">    attributes, this behavior can be changed, so that it is only defined on that interval,</span>
<span class="sd">    and is zero or continuous outside of that interval (see the attributes</span>
<span class="sd">    :attr:`~zero_before` and :attr:`~zero_after`).</span>

<span class="sd">    The usual workflow is to instantiate a model, then fit it to a timeseries, saving</span>
<span class="sd">    the parameters, and then evaluate it later. For synthetic timeseries, it is</span>
<span class="sd">    instantiated and the parameters are set manually.</span>

<span class="sd">    A minimal user-defined subclass should look similar to :class:`~geonat.models.Polynomial`</span>
<span class="sd">    or :class:`~geonat.models.Exponential`. Three methods need to be provided: an</span>
<span class="sd">    ``__init__()`` function that takes in any model-specific parameters and passes all</span>
<span class="sd">    other parameters into the parent class through ``super().__init__()``, as well as</span>
<span class="sd">    both :meth:`~_get_mapping` and :meth:`~_get_arch` (see the base class&#39; documentation</span>
<span class="sd">    for expected in- and output).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_parameters : int</span>
<span class="sd">        Number of model parameters.</span>
<span class="sd">    regularize : bool, optional</span>
<span class="sd">        If ``True``, regularization-capable solvers will regularize the</span>
<span class="sd">        parameters of this model.</span>
<span class="sd">    time_unit : str, optional</span>
<span class="sd">        Time unit for parameters.</span>
<span class="sd">        Refer to :class:`~geonat.tools.Timedelta` for more details.</span>
<span class="sd">    t_start : str, pandas.Timestamp or None, optional</span>
<span class="sd">        Sets the model start time (attributes :attr:`~t_start` and :attr:`t_start_str`).</span>
<span class="sd">    t_end : str, pandas.Timestamp or None, optional</span>
<span class="sd">        Sets the model end time (attributes :attr:`~t_end` and :attr:`t_end_str`).</span>
<span class="sd">    t_reference : str, pandas.Timestamp or None, optional</span>
<span class="sd">        Sets the model reference time (attributes :attr:`~t_reference`</span>
<span class="sd">        and :attr:`t_reference_str`).</span>
<span class="sd">    zero_before : bool, optional</span>
<span class="sd">        Defines whether the model is zero before ``t_start``, or</span>
<span class="sd">        if the boundary value should be used (attribute :attr:`~zero_before`).</span>
<span class="sd">    zero_after : bool, optional</span>
<span class="sd">        Defines whether the model is zero after ``t_end``, or</span>
<span class="sd">        if the boundary value should be used (attribute :attr:`~zero_after`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EVAL_PREDVAR_PRECISION</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To reduce memory impact when estimating the full covariance of the predicted</span>
<span class="sd">    timeseries when calling :meth:`~evaluate`, this attribute is by default set to</span>
<span class="sd">    single precision, but can be changed to double precision if desired.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_parameters</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">t_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">zero_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># define model settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_parameters</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Number of parameters that define the model and can be solved for. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="s2">&quot;&#39;num_parameters&#39; must be an integer greater or equal to one, &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regularize</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">regularize</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Indicate to solvers to regularize this model (``True``) or not. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_unit</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">time_unit</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Stores the time unit of the parameters as a string. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_start_str</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; String representation of the start time (or ``None``). &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_end_str</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">t_end</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; String representation of the end time (or ``None``). &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_reference_str</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">t_reference</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; String representation of the reference time (or ``None``). &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; :class:`~pandas.Timestamp` representation of the start time (or ``None``). &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_end</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_end</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; :class:`~pandas.Timestamp` representation of the end time (or ``None``). &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_reference</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; :class:`~pandas.Timestamp` representation of the reference time (or ``None``). &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_before</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">zero_before</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``True``, model will evaluate to zero before the start time, otherwise the</span>
<span class="sd">        model value at the start time will be used for all times before that.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_after</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">zero_after</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``True``, model will evaluate to zero after the end time, otherwise the</span>
<span class="sd">        model value at the end time will be used for all times after that.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        By default, all parameters in the model are considered active, and this attribute is</span>
<span class="sd">        set to ``None``. Otherwise, this attribute contains an array of shape</span>
<span class="sd">        :math:`(\text{num_parameters}, )` with ``True`` where parameters are active, and</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize data variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">par</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array property of shape :math:`(\text{num_parameters}, \text{num_components})`</span>
<span class="sd">        that contains the parameters as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Alias for :attr:`~par`. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array property of shape :math:`(\text{num_parameters}, \text{num_components})`</span>
<span class="sd">        that returns the parameter&#39;s individual variances as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Square array property with dimensions</span>
<span class="sd">        :math:`\text{num_elements} * \text{num_components}` that contains the parameter&#39;s</span>
<span class="sd">        full covariance matrix as a NumPy array. The rows (and columns) are ordered such</span>
<span class="sd">        that they first correspond to the covariances between all components for the first</span>
<span class="sd">        parameter, then the covariance between all components for the second parameter,</span>
<span class="sd">        and so forth.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span>

<div class="viewcode-block" id="Model.__str__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function that returns a readable summary of the Model.</span>
<span class="sd">        Accessed, for example, by Python&#39;s ``print()`` built-in function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        info : str</span>
<span class="sd">            Model summary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arch</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> model (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="si">}</span><span class="s2"> parameters)&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;kw_args&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="s1">&#39;:&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="Model.__eq__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function that allows for the comparison of models based on their</span>
<span class="sd">        type and architecture, regardless of model parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geonat.models.Model</span>
<span class="sd">            Model to compare to.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from geonat.models import Step, Sinusoidal</span>
<span class="sd">        &gt;&gt;&gt; step1, step2 = Step([&quot;2020-01-01&quot;]), Step([&quot;2020-01-02&quot;])</span>
<span class="sd">        &gt;&gt;&gt; sin1, sin2 = Sinusoidal(1, &quot;2020-01-01&quot;), Sinusoidal(1, &quot;2020-01-01&quot;)</span>
<span class="sd">        &gt;&gt;&gt; step1 == step2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; sin1 == sin2</span>
<span class="sd">        True</span>

<span class="sd">        Note that obviously, the objects themselves are still different:</span>

<span class="sd">        &gt;&gt;&gt; step1 is step1</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; step1 is step2</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_arch : Function used to determine the equality.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()</span></div>

<div class="viewcode-block" id="Model.get_arch"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.get_arch">[docs]</a>    <span class="k">def</span> <span class="nf">get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary that describes the model fully and allows it to be recreated.</span>
<span class="sd">        Requires the model to be subclassed and implement a :meth:`_get_arch` method</span>
<span class="sd">        that expands the base model keywords to the subclassed model details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arch : dict</span>
<span class="sd">            Model keyword dictionary.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the model has not been subclassed and :meth:`~_get_arch` has not been added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make base architecture</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Model&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_parameters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;regularize&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularize</span><span class="p">,</span>
                            <span class="s2">&quot;time_unit&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_unit</span><span class="p">,</span>
                            <span class="s2">&quot;t_start&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start_str</span><span class="p">,</span>
                            <span class="s2">&quot;t_end&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_end_str</span><span class="p">,</span>
                            <span class="s2">&quot;t_reference&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_reference_str</span><span class="p">,</span>
                            <span class="s2">&quot;zero_before&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_before</span><span class="p">,</span>
                            <span class="s2">&quot;zero_after&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_after</span><span class="p">}}</span>
        <span class="c1"># get subclass-specific architecture</span>
        <span class="n">instance_arch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_arch</span><span class="p">()</span>
        <span class="c1"># update non-dictionary values</span>
        <span class="n">arch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">arg</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">instance_arch</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">arg</span> <span class="o">!=</span> <span class="s2">&quot;kw_args&quot;</span><span class="p">})</span>
        <span class="c1"># update keyword dictionary</span>
        <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;kw_args&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">instance_arch</span><span class="p">[</span><span class="s2">&quot;kw_args&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">arch</span></div>

<div class="viewcode-block" id="Model._get_arch"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model._get_arch">[docs]</a>    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subclass-specific model keyword dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arch : dict</span>
<span class="sd">            Model keyword dictionary. Must have keys ``&#39;type&#39;`` and ``&#39;kw_args&#39;``,</span>
<span class="sd">            with a string and a dictionary as values, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Instantiated model was not subclassed or &quot;</span>
                                  <span class="s2">&quot;it does not overwrite the &#39;_get_arch&#39; method.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.freeze"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.freeze">[docs]</a>    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero_threshold</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In case some parameters are estimated to be close to zero and should not</span>
<span class="sd">        be considered in future fits and evaluations, this function &quot;freezes&quot;</span>
<span class="sd">        the model by setting parameters below the threshold ``zero_threshold``</span>
<span class="sd">        to be invalid. The mask will be kept in :attr:`~active_parameters`.</span>

<span class="sd">        Only valid parameters will be used by :meth:`~get_mapping` and</span>
<span class="sd">        :meth:`~evaluate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zero_threshold : float, optional</span>
<span class="sd">            Model parameters with absolute values below ``zero_threshold`` will be</span>
<span class="sd">            set to zero and set inactive. Defaults to ``1e-10``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        unfreeze : The reverse method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">float</span><span class="p">(</span><span class="n">zero_threshold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;&#39;zero_threshold needs to be non-negative, got </span><span class="si">{</span><span class="n">zero_threshold</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot freeze a model without set parameters.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inactive_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inactive_ix</span><span class="p">,</span> <span class="n">inactive_ix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Model.unfreeze"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.unfreeze">[docs]</a>    <span class="k">def</span> <span class="nf">unfreeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets previous model freezing done by :meth:`~freeze` such that all parameters</span>
<span class="sd">        are active again.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        freeze : The reverse method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Model.get_mapping"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.get_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">,</span> <span class="n">return_observability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_active_parameters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the mapping matrix :math:`\mathbf{G}` given a time vector :math:`\mathbf{t}`.</span>
<span class="sd">        Requires the model to be subclassed and implement a :meth:`~_get_mapping` method.</span>

<span class="sd">        This method has multiple steps: it first checks the active period of the</span>
<span class="sd">        model using :meth:`~get_active_period`. If ``timevector`` is outside the active period,</span>
<span class="sd">        it skips the actual calculation and returns an empty sparse matrix. If there is at least</span>
<span class="sd">        one timestamp where the model is active, it calls the actual :meth:`~_get_mapping`</span>
<span class="sd">        mapping matrix calculation method only for the timestamps where the model is active in</span>
<span class="sd">        order to reduce the computational load. Lastly, the dense, evaluated mapping matrix</span>
<span class="sd">        gets padded before and after with empty sparse matrices (if the model is zero outside</span>
<span class="sd">        its boundaries) or the values at the boundaries themselves.</span>

<span class="sd">        This method respects the parameters being set invalid by :meth:`~freeze`, and will</span>
<span class="sd">        interpret those parameters to be unobservable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>
<span class="sd">        return_observability : bool, optional</span>
<span class="sd">            If true, the function will check if there are any all-zero columns, which</span>
<span class="sd">            would point to unobservable parameters, and return a boolean mask with the</span>
<span class="sd">            valid indices.</span>
<span class="sd">        ignore_active_parameters : bool, optional</span>
<span class="sd">            If ``True``, do not set inactive parameters to zero to avoid estimation.</span>
<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mapping : scipy.sparse.csc_matrix</span>
<span class="sd">            Sparse mapping matrix.</span>
<span class="sd">        observable : numpy.ndarray</span>
<span class="sd">            Returned if ``return_observability=True``.</span>
<span class="sd">            A boolean NumPy array of the same length as ``mapping`` has columns.</span>
<span class="sd">            ``False`` indicates (close to) all-zero columns (unobservable parameters).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the model has not been subclassed and :meth:`~_get_mapping` has not been added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get active period and initialize coefficient matrix</span>
        <span class="n">active</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_period</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span>
        <span class="c1"># if there isn&#39;t any active period, return csc-sparse matrix</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">last</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># this is equivalent to not active.any()</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">timevector</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">return_observability</span><span class="p">:</span>
                <span class="n">observable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># otherwise, build coefficient matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># build dense sub-matrix</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">timevector</span><span class="p">[</span><span class="n">active</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;The child function &#39;_get_mapping&#39; of model </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;returned an invalid shape. &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;Expected was (</span><span class="si">{</span><span class="n">last</span><span class="o">-</span><span class="n">first</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="si">}</span><span class="s2">), got </span><span class="si">{</span><span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="c1"># if model is frozen, zero out inactive parameters</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ignore_active_parameters</span><span class="p">):</span>
                <span class="n">coefs</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">return_observability</span><span class="p">:</span>
                <span class="c1"># check for the number effective non-zero coefficients</span>
                <span class="c1"># technically observable where we have at least one such value</span>
                <span class="c1"># for regularized models, also skip all columns with just a single value,</span>
                <span class="c1"># as this would just map into another constant offset, which should</span>
                <span class="c1"># be taken care of by a non-regularized polynomial</span>
                <span class="n">maxamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coefs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">maxamps</span><span class="p">[</span><span class="n">maxamps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">numnotzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">coefs</span> <span class="o">/</span> <span class="n">maxamps</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">observable</span> <span class="o">=</span> <span class="n">numnotzero</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularize</span> <span class="k">else</span> <span class="n">numnotzero</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># build before- and after-matrices</span>
            <span class="c1"># either use zeros or the values at the active boundaries for padding</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_before</span><span class="p">:</span>
                <span class="n">before</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">before</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">))</span>
                                           <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_after</span><span class="p">:</span>
                <span class="n">after</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">timevector</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">after</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">timevector</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">))</span>
                                          <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># stack them (they can have 0 in the first dimension, no problem for sparse.vstack)</span>
            <span class="c1"># I think it&#39;s faster if to stack them if they&#39;re all already csc format</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">before</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">coefs</span><span class="p">),</span> <span class="n">after</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
        <span class="c1"># return</span>
        <span class="k">if</span> <span class="n">return_observability</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">observable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mapping</span></div>

<div class="viewcode-block" id="Model._get_mapping"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model._get_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the mapping matrix :math:`\mathbf{G}` given a time vector :math:`\mathbf{t}`</span>
<span class="sd">        for the active period. Called inside :meth:`~get_mapping`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>
<span class="sd">            It can and should be assumed that all included timestamps are valid</span>
<span class="sd">            (i.e., defined by the model&#39;s :attr:`~zero_before` and :attr:`~zero_after`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coefs : numpy.ndarray</span>
<span class="sd">            Mapping matrix with the same number of rows as ``timevector`` and</span>
<span class="sd">            :attr:`~num_parameters` columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;Model&#39; needs to be subclassed and its child needs to &quot;</span>
                                  <span class="s2">&quot;implement a &#39;_get_mapping&#39; function for the active period.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.get_active_period"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.get_active_period">[docs]</a>    <span class="k">def</span> <span class="nf">get_active_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a time vector, return at each point whether the model is active.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        active : numpy.ndarray</span>
<span class="sd">            Array of same length as ``timevector``, with ``True`` where active.</span>
<span class="sd">        first : int</span>
<span class="sd">            Index of the first active timestamp.</span>
<span class="sd">        last : int</span>
<span class="sd">            Index of the last active Timestamp.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">active</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">timevector</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">active</span> <span class="o">=</span> <span class="n">timevector</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_end</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">active</span> <span class="o">=</span> <span class="n">timevector</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">timevector</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">timevector</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_end</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">active</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">active</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">active</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">active</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span></div>

<div class="viewcode-block" id="Model.tvec_to_numpycol"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.tvec_to_numpycol">[docs]</a>    <span class="k">def</span> <span class="nf">tvec_to_numpycol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience wrapper for :func:`~geonat.tools.tvec_to_numpycol` for Model objects that have</span>
<span class="sd">        the :attr:`~time_unit` and :attr:`~t_reference` attributes set.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~geonat.tools.tvec_to_numpycol` : Convert a Timestamp vector into a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t call &#39;tvec_to_numpycol&#39; because no reference time &quot;</span>
                             <span class="s2">&quot;was specified in the model.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t call &#39;tvec_to_numpycol&#39; because no time unit &quot;</span>
                             <span class="s2">&quot;was specified in the model.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.read_parameters"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.read_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">read_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads in the parameters :math:`\mathbf{m}` (optionally also their</span>
<span class="sd">        covariance) and stores them in the instance attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : numpy.ndarray</span>
<span class="sd">            Model parameters of shape</span>
<span class="sd">            :math:`(\text{num_parameters}, \text{num_components})`.</span>
<span class="sd">        covariances : numpy.ndarray, optional</span>
<span class="sd">            Model component (co-)variances that can either have the same shape as</span>
<span class="sd">            ``parameters``, in which case every parameter and component only has a</span>
<span class="sd">            variance, or it is square with dimensions</span>
<span class="sd">            :math:`\text{num_parameters} * \text{num_components}`, in which case it</span>
<span class="sd">            represents a full variance-covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># quick check if this is just a reset</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="c1"># check and set parameters</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">==</span> <span class="n">parameters</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> \
            <span class="s2">&quot;Read-in parameters have different size than the instantiated model. &quot;</span> <span class="o">+</span> \
            <span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">parameters</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">[0].&quot;</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">act_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span>
        <span class="k">if</span> <span class="n">act_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="o">~</span><span class="n">act_params</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> \
                <span class="s2">&quot;Something went wrong: inactive parameters should be estimated as 0.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="n">par</span>
        <span class="c1"># check and set covariances</span>
        <span class="k">if</span> <span class="n">covariances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">covariances</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> \
                <span class="s2">&quot;Covariance matrix must have shape &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">covariances</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">if</span> <span class="n">act_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">active_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">act_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">covariances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="o">~</span><span class="n">active_ix</span><span class="p">,</span> <span class="o">~</span><span class="n">active_ix</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> \
                    <span class="s2">&quot;Something went wrong: covariance for inactive parameters should be 0.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="n">covariances</span></div>

<div class="viewcode-block" id="Model.evaluate"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Model.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the model given a time vector (calculates :math:`\mathbf{d}`</span>
<span class="sd">        and its (co)variance, if applicable).</span>

<span class="sd">        This method ignores the parameters being set invalid by :meth:`~freeze`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with the keys ``time`` containing the input time vector,</span>
<span class="sd">            ``fit`` containing :math:`\mathbf{d}`, and ``var`` containing</span>
<span class="sd">            the formal variance (or ``None``, if not present). ``fit`` and ``var``</span>
<span class="sd">            (if not ``None``) are :class:`~numpy.ndarray` objects.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the model parameters have not yet been set with :meth:`~read_parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot evaluate the model before reading in parameters.&quot;</span><span class="p">)</span>
        <span class="n">mapping_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">timevector</span><span class="o">=</span><span class="n">timevector</span><span class="p">)</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">mapping_matrix</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fit_var</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">fit_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># repeat the mapping matrix for all components,</span>
            <span class="c1"># same order as full_cov_mat_to_columns needs</span>
            <span class="n">num_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">map_mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">mapping_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_components</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csc&quot;</span><span class="p">)</span>
            <span class="c1"># reduce the size of matrix calculation by removing all-zero rows and columns</span>
            <span class="n">var_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span>
            <span class="n">rowcolnonzero</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">var_full</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">rowcolnonzero</span> <span class="o">==</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">var_full</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">var_full</span> <span class="o">=</span> <span class="n">var_full</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rowcolnonzero</span><span class="p">,</span> <span class="n">rowcolnonzero</span><span class="p">)]</span>
            <span class="n">map_mat</span> <span class="o">=</span> <span class="n">map_mat</span><span class="p">[:,</span> <span class="n">rowcolnonzero</span><span class="p">]</span><span class="o">.</span><span class="n">A</span>
            <span class="c1"># calculate the predicted variance</span>
            <span class="n">pred_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">map_mat</span> <span class="o">@</span> <span class="n">var_full</span><span class="p">,</span> <span class="n">map_mat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">EVAL_PREDVAR_PRECISION</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">)</span>
            <span class="c1"># extract the (block-)diagonal components and reshape</span>
            <span class="n">fit_var</span><span class="p">,</span> <span class="n">fit_cov</span> <span class="o">=</span> <span class="n">full_cov_mat_to_columns</span><span class="p">(</span><span class="n">pred_var</span><span class="p">,</span> <span class="n">num_components</span><span class="p">,</span>
                                                       <span class="n">include_covariance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">timevector</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">:</span> <span class="n">fit</span><span class="p">,</span> <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="n">fit_var</span><span class="p">,</span> <span class="s2">&quot;cov&quot;</span><span class="p">:</span> <span class="n">fit_cov</span><span class="p">}</span></div></div>


<div class="viewcode-block" id="Step"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Step">[docs]</a><span class="k">class</span> <span class="nc">Step</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    Model that introduces steps at discrete times.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    steptimes : list</span>
<span class="sd">        List of datetime-like strings that can be converted into :class:`~pandas.Timestamp`.</span>
<span class="sd">        Length of it equals the number of model parameters.</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steptimes</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">steptimes</span><span class="p">),</span> <span class="n">zero_after</span><span class="o">=</span><span class="n">zero_after</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steptimes</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; List of step times as :class:`~pandas.Timestamp`. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span> <span class="o">=</span> <span class="p">[</span><span class="n">step</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; List of step times as datetime-like strings. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Step&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;steptimes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_update_from_steptimes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span> <span class="o">=</span> <span class="p">[</span><span class="n">step</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Step.add_step"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Step.add_step">[docs]</a>    <span class="k">def</span> <span class="nf">add_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a step to the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step : str</span>
<span class="sd">            Datetime-like string of the step time to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step &#39;</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&#39; already present.&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_from_steptimes</span><span class="p">()</span></div>

<div class="viewcode-block" id="Step.remove_step"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Step.remove_step">[docs]</a>    <span class="k">def</span> <span class="nf">remove_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a step from the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step : str</span>
<span class="sd">            Datetime-like string of the step time to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steptimes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_from_steptimes</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step &#39;</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&#39; not present.&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timevector</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span>
                         <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="p">,</span>
                                      <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;steptime&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span></div>


<div class="viewcode-block" id="Polynomial"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Polynomial">[docs]</a><span class="k">class</span> <span class="nc">Polynomial</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    Polynomial model of given order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order : int</span>
<span class="sd">        Order (highest exponent) of the polynomial. The number of model parameters</span>
<span class="sd">        equals ``order + 1 - min_exponent``.</span>
<span class="sd">    min_exponent : int, optional</span>
<span class="sd">        Lowest exponent of the polynomial. Defaults to ``0``, i.e. the constant offset.</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span> <span class="n">min_exponent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">zero_before</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">min_exponent</span><span class="p">,</span>
                         <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span>
                         <span class="n">zero_before</span><span class="o">=</span><span class="n">zero_before</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="n">zero_after</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_exponent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_exponent</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Polynomial&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="s2">&quot;min_exponent&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_exponent</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span>
        <span class="c1"># the exponents increase by column</span>
        <span class="n">exponents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_exponent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># broadcast to all coefficients</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">exponents</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span></div>


<div class="viewcode-block" id="BSpline"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.BSpline">[docs]</a><span class="k">class</span> <span class="nc">BSpline</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    Model defined by cardinal, centralized B-Splines of certain order/degree and time scale.</span>
<span class="sd">    Used for transient temporary signals that return to zero after a given time span.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    degree : int</span>
<span class="sd">        Degree of the B-Splines.</span>
<span class="sd">    scale : float</span>
<span class="sd">        Scale of the B-Splines, see Notes.</span>
<span class="sd">    t_reference : str or pandas.Timestamp</span>
<span class="sd">        Reference (center) time for (first) spline.</span>
<span class="sd">    time_unit : str</span>
<span class="sd">        Time unit of scale, spacing and model parameters.</span>
<span class="sd">    num_splines : int, optional</span>
<span class="sd">        Number of splines, separated by ``spacing``. Defaults to ``1``.</span>
<span class="sd">    spacing : float, optional</span>
<span class="sd">        Spacing between the center times when multiple splines are created.</span>
<span class="sd">        Defaults to ``scale``.</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    For an analytic representation of the B-Splines, see [butzer88]_ or [schoenberg73]_.</span>
<span class="sd">    Further examples can be found at `&lt;https://bsplines.org/flavors-and-types-of-b-splines/&gt;`_.</span>

<span class="sd">    It is important to note that the function will be non-zero on the interval</span>

<span class="sd">    .. math:: -(p+1)/2 &lt; x &lt; (p+1)/2</span>

<span class="sd">    where :math:`p` is the degree of the cardinal B-spline (and the degree of the</span>
<span class="sd">    resulting polynomial). The order :math:`n` is related to the degree by the relation</span>
<span class="sd">    :math:`n = p + 1`. The scale determines the width of the spline in the time domain,</span>
<span class="sd">    and corresponds to the interval [0, 1] of the B-Spline. The full non-zero time span</span>
<span class="sd">    of the spline is therefore :math:`\text{scale} \cdot (p+1) = \text{scale} \cdot n`.</span>

<span class="sd">    ``num_splines`` will increase the number of splines by shifting the reference</span>
<span class="sd">    point :math:`(\text{num_splines} - 1)` times by the spacing (which must be given</span>
<span class="sd">    in the same units as the scale).</span>

<span class="sd">    If no spacing is given but multiple splines are requested, the scale will be used</span>
<span class="sd">    as the spacing.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [butzer88] Butzer, P., Schmidt, M., &amp; Stark, E. (1988).</span>
<span class="sd">       *Observations on the History of Central B-Splines.*</span>
<span class="sd">       Archive for History of Exact Sciences, 39(2), 137-156. Retrieved May 14, 2020,</span>
<span class="sd">       from `&lt;https://www.jstor.org/stable/41133848&gt;`_</span>
<span class="sd">    .. [schoenberg73] Schoenberg, I. J. (1973). *Cardinal Spline Interpolation.*</span>
<span class="sd">       Society for Industrial and Applied Mathematics.</span>
<span class="sd">       doi:`10.1137/1.9781611970555 &lt;https://doi.org/10.1137/1.9781611970555&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">num_splines</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Degree :math:`p` of the B-Splines. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&#39;degree&#39; needs to be greater or equal to 0.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot; Order :math:`n=p+1` of the B-Splines. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Scale of the splines. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot; Spacing between the center times of the splines. &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;&#39;spacing&#39; must be non-zero to avoid singularities, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">if</span> <span class="n">num_splines</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;spacing&#39; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">time_unit</span><span class="si">}</span><span class="s2">) is given, but &quot;</span>
                     <span class="s2">&quot;&#39;num_splines&#39; = 1 splines are requested.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_splines</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;t_start&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_kw_args</span> <span class="ow">or</span> <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_start&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_reference</span><span class="p">)</span>
                                        <span class="o">-</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
                                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;t_end&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_kw_args</span> <span class="ow">or</span> <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_end&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_reference</span><span class="p">)</span>
                                      <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="n">num_splines</span>
                                      <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="n">num_splines</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span>
                         <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="n">regularize</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centertimes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a :class:`~pandas.Series` with all center times. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span> <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_unit</span><span class="p">)</span> <span class="o">*</span> <span class="n">spl</span>
                          <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;BSpline&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                            <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                            <span class="s2">&quot;num_splines&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span>
                            <span class="s2">&quot;spacing&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">trel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> \
               <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tnorm</span> <span class="o">=</span> <span class="n">trel</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">in_power</span> <span class="o">=</span> <span class="n">tnorm</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">krange</span>
        <span class="n">in_sum</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">krange</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">krange</span><span class="p">)</span>
                  <span class="o">*</span> <span class="p">(</span><span class="n">in_power</span> <span class="o">*</span> <span class="p">(</span><span class="n">in_power</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">))</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span>

<div class="viewcode-block" id="BSpline.get_transient_period"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.BSpline.get_transient_period">[docs]</a>    <span class="k">def</span> <span class="nf">get_transient_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mask-like array of where each spline is currently transient</span>
<span class="sd">        (not staying constant).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transient : numpy.ndarray</span>
<span class="sd">            NumPy array with ``True`` when a spline is currently transient,</span>
<span class="sd">            ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trel</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">transient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trel</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
        <span class="k">return</span> <span class="n">transient</span></div></div>


<div class="viewcode-block" id="ISpline"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ISpline">[docs]</a><span class="k">class</span> <span class="nc">ISpline</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    Integral of cardinal, centralized B-Splines of certain order/degree and time scale,</span>
<span class="sd">    with an amplitude of 1.</span>
<span class="sd">    The degree :math:`p` given in the initialization is the degree of the spline</span>
<span class="sd">    *before* the integration, i.e. the resulting ISpline is a piecewise polynomial</span>
<span class="sd">    of degree :math:`p + 1`. Used for transient permanent signals that stay at their</span>
<span class="sd">    maximum value after a given time span.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geonat.models.BSpline : More details about B-Splines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">num_splines</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Degree :math:`p` of the B-Splines. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&#39;degree&#39; needs to be greater or equal to 0.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot; Order :math:`n=p+1` of the B-Splines. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Scale of the splines. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot; Spacing between the center times of the splines. &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;&#39;spacing&#39; must be non-zero to avoid singularities, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">if</span> <span class="n">num_splines</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;spacing&#39; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">time_unit</span><span class="si">}</span><span class="s2">) is given, &quot;</span>
                     <span class="s2">&quot;but &#39;num_splines&#39; = 1 splines are requested.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_splines</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;t_start&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_kw_args</span> <span class="ow">or</span> <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_start&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_reference</span><span class="p">)</span>
                                        <span class="o">-</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
                                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;t_end&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_kw_args</span> <span class="ow">or</span> <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_end&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_kw_args</span><span class="p">[</span><span class="s2">&quot;t_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_reference</span><span class="p">)</span>
                                      <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="n">num_splines</span>
                                      <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="n">num_splines</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span>
                         <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="n">zero_after</span><span class="p">,</span>
                         <span class="n">regularize</span><span class="o">=</span><span class="n">regularize</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centertimes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a :class:`~pandas.Series` with all center times. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span> <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_unit</span><span class="p">)</span> <span class="o">*</span> <span class="n">spl</span>
                          <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ISpline&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                            <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                            <span class="s2">&quot;num_splines&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span>
                            <span class="s2">&quot;spacing&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">trel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> \
               <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tnorm</span> <span class="o">=</span> <span class="n">trel</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">in_power</span> <span class="o">=</span> <span class="n">tnorm</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">krange</span>
        <span class="n">in_sum</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">krange</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">krange</span><span class="p">)</span>
                  <span class="o">*</span> <span class="p">(</span><span class="n">in_power</span> <span class="o">*</span> <span class="p">(</span><span class="n">in_power</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span>

<div class="viewcode-block" id="ISpline.get_transient_period"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ISpline.get_transient_period">[docs]</a>    <span class="k">def</span> <span class="nf">get_transient_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mask-like array of where each spline is currently transient</span>
<span class="sd">        (not staying constant).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transient : numpy.ndarray</span>
<span class="sd">            NumPy array with ``True`` when a spline is currently transient, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trel</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">transient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trel</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
        <span class="k">return</span> <span class="n">transient</span></div></div>


<div class="viewcode-block" id="SplineSet"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.SplineSet">[docs]</a><span class="k">class</span> <span class="nc">SplineSet</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    Contains a list of splines that share a common degree, but different center</span>
<span class="sd">    times and scales.</span>

<span class="sd">    The set is constructed from a time span (``t_center_start`` and ``t_center_end``)</span>
<span class="sd">    and numbers of centerpoints or length scales. By default (``complete=True``),</span>
<span class="sd">    the number of splines and center points for each scale will then be chosen such</span>
<span class="sd">    that the resulting set of splines will be complete over the input time scale.</span>
<span class="sd">    This means it will contain all splines that are non-zero at least somewhere in</span>
<span class="sd">    the time span. Otherwise, the spline set will only have center times at or</span>
<span class="sd">    between ``t_center_start`` and ``t_center_end``.</span>

<span class="sd">    This class also sets the spacing equal to the scale.</span>

<span class="sd">    Lastly, in order to influence the tradeoff between splines of different timescales,</span>
<span class="sd">    the mapping matrix of each spline is scaled by its own time scale to promote using</span>
<span class="sd">    fewer components. Without this, there would be an ambiguity for the solver as to</span>
<span class="sd">    whether fit the signal using many smaller scales or with one large scale, as the</span>
<span class="sd">    fit would be almost identical. This behavior can be disabled by setting</span>
<span class="sd">    ``internal_scaling=False``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    degree : int</span>
<span class="sd">        Degree of the splines to be created.</span>
<span class="sd">    t_center_start : str or pandas.Timestamp</span>
<span class="sd">        Time span start of the spline set.</span>
<span class="sd">    t_center_end : str or pandas.Timestamp</span>
<span class="sd">        Time span end of the spline set.</span>
<span class="sd">    time_unit : str</span>
<span class="sd">        Time unit of scale, spacing and model parameters.</span>
<span class="sd">    list_scales : list</span>
<span class="sd">        List of scales to use for each of the sub-splines.</span>
<span class="sd">        Mutually exclusive to setting ``list_num_knots``.</span>
<span class="sd">    list_num_knots : list</span>
<span class="sd">        List of number of knots to divide the time span into for each of the sub-splines.</span>
<span class="sd">        Mutually exclusive to setting ``list_scales``.</span>
<span class="sd">    splineclass : Model, optional</span>
<span class="sd">        Model class to use for the splines. Defaults to :class:`~geonat.models.ISpline`.</span>
<span class="sd">    complete : bool, optional</span>
<span class="sd">        See usage description. Defaults to ``True``.</span>
<span class="sd">    internal_scaling : bool, optional</span>
<span class="sd">        See usage description. Defaults to ``True``.</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">t_center_start</span><span class="p">,</span> <span class="n">t_center_end</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span>
                 <span class="n">list_scales</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">list_num_knots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">splineclass</span><span class="o">=</span><span class="n">ISpline</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">internal_scaling</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">list_scales</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="n">list_num_knots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> \
            <span class="s2">&quot;To construct a set of Splines, pass exactly one of &quot;</span> \
            <span class="s2">&quot;&#39;list_scales&#39; and &#39;list_num_knots&#39; &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;(got </span><span class="si">{</span><span class="n">list_scales</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">list_num_knots</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="n">relevant_list</span> <span class="o">=</span> <span class="n">list_scales</span> <span class="k">if</span> <span class="n">list_num_knots</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">list_num_knots</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">splineclass</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">splineclass</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">splineclass</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">splineclass</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s2">&quot;When trying to create the SplineSet, couldn&#39;t find the model &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">splineclass</span><span class="si">}</span><span class="s2">&#39; (expected Model type argument or string &quot;</span>
                              <span class="s2">&quot;representation of a loaded Model).&quot;</span>
                              <span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="c1"># get time range</span>
        <span class="n">t_center_start_tstamp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_center_start</span><span class="p">)</span>
        <span class="n">t_center_end_tstamp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">t_center_end</span><span class="p">)</span>
        <span class="n">t_center_start</span> <span class="o">=</span> <span class="n">t_center_start_tstamp</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">t_center_end</span> <span class="o">=</span> <span class="n">t_center_end_tstamp</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">t_range_tdelta</span> <span class="o">=</span> <span class="n">t_center_end_tstamp</span> <span class="o">-</span> <span class="n">t_center_start_tstamp</span>
        <span class="c1"># if a complete set is requested, we need to find the number of overlaps</span>
        <span class="c1"># given the degree on a single side</span>
        <span class="n">num_overlaps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">degree</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="k">if</span> <span class="n">complete</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="c1"># for each scale, make a BSplines object</span>
        <span class="n">splset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_parameters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">relevant_list</span><span class="p">:</span>
            <span class="c1"># Calculate the scale as float and Timedelta depending on the function call</span>
            <span class="k">if</span> <span class="n">list_scales</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scale_float</span> <span class="o">=</span> <span class="n">elem</span>
                <span class="n">scale_tdelta</span> <span class="o">=</span> <span class="n">Timedelta</span><span class="p">(</span><span class="n">scale_float</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale_tdelta</span> <span class="o">=</span> <span class="n">t_range_tdelta</span> <span class="o">/</span> <span class="p">(</span><span class="n">elem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">scale_float</span> <span class="o">=</span> <span class="n">scale_tdelta</span> <span class="o">/</span> <span class="n">Timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">)</span>
            <span class="c1"># find the number of center points between t_center_start and t_center_end,</span>
            <span class="c1"># plus the overlapping ones</span>
            <span class="n">num_centerpoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t_range_tdelta</span> <span class="o">/</span> <span class="n">scale_tdelta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">num_overlaps</span>
            <span class="n">num_parameters</span> <span class="o">+=</span> <span class="n">num_centerpoints</span>
            <span class="c1"># shift the reference to be the first spline</span>
            <span class="n">t_ref</span> <span class="o">=</span> <span class="n">t_center_start_tstamp</span> <span class="o">-</span> <span class="n">num_overlaps</span><span class="o">*</span><span class="n">scale_tdelta</span>
            <span class="c1"># create model and append</span>
            <span class="n">splset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splineclass</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">scale_float</span><span class="p">,</span> <span class="n">num_splines</span><span class="o">=</span><span class="n">num_centerpoints</span><span class="p">,</span>
                          <span class="n">t_reference</span><span class="o">=</span><span class="n">t_ref</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="n">regularize</span><span class="p">))</span>
        <span class="c1"># create the actual Model object</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="n">num_parameters</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span>
                         <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span> <span class="k">if</span> <span class="n">splineclass</span> <span class="o">==</span> <span class="n">ISpline</span> <span class="k">else</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">regularize</span><span class="o">=</span><span class="n">regularize</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="sd">&quot;&quot;&quot; Degree of the splines. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_center_start</span> <span class="o">=</span> <span class="n">t_center_start</span>
        <span class="sd">&quot;&quot;&quot; Relevant time span start. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_center_end</span> <span class="o">=</span> <span class="n">t_center_end</span>
        <span class="sd">&quot;&quot;&quot; Relevant time span end. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splineclass</span> <span class="o">=</span> <span class="n">splineclass</span>
        <span class="sd">&quot;&quot;&quot; Class of the splines contained. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_scales</span> <span class="o">=</span> <span class="n">list_scales</span>
        <span class="sd">&quot;&quot;&quot; List of scales of each of the sub-splines. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_num_knots</span> <span class="o">=</span> <span class="n">list_num_knots</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of number of knots the time span is divided into for each of the sub-splines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">complete</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets whether the spline coverage of the time span is considered to be complete or not</span>
<span class="sd">        (see class documentation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splines</span> <span class="o">=</span> <span class="n">splset</span>
        <span class="sd">&quot;&quot;&quot; List of spline object contained within the SplineSet. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_scaling</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">internal_scaling</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Trackes whether to scale the sub-splines relative to their lengths. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_scale</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">])</span>
        <span class="sd">&quot;&quot;&quot; Minimum scale of the sub-splines. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">scale</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span>
                                                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">])</span> <span class="o">/</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">min_scale</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scaling</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If :attr:`~internal_scaling` is ``True``, this NumPy array holds the relative</span>
<span class="sd">        scaling factors of all parameters over all the sub-splines.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;SplineSet&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                            <span class="s2">&quot;t_center_start&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_center_start</span><span class="p">,</span>
                            <span class="s2">&quot;t_center_end&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_center_end</span><span class="p">,</span>
                            <span class="s2">&quot;splineclass&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">splineclass</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                            <span class="s2">&quot;list_scales&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_scales</span><span class="p">,</span>
                            <span class="s2">&quot;list_num_knots&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_num_knots</span><span class="p">,</span>
                            <span class="s2">&quot;complete&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete</span><span class="p">,</span>
                            <span class="s2">&quot;internal_scaling&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scaling</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">timevector</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">))</span>
        <span class="n">ix_coefs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">:</span>
            <span class="n">coefs</span><span class="p">[:,</span> <span class="n">ix_coefs</span><span class="p">:</span><span class="n">ix_coefs</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">model</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">ix_coefs</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scaling</span><span class="p">:</span>
            <span class="n">coefs</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span>

<div class="viewcode-block" id="SplineSet.freeze"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.SplineSet.freeze">[docs]</a>    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero_threshold</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In case some parameters are estimated to be close to zero and should not</span>
<span class="sd">        be considered in future fits and evaluations, this function &quot;freezes&quot;</span>
<span class="sd">        the model by setting parameters below the threshold ``zero_threshold``</span>
<span class="sd">        to be invalid. The mask will be kept in</span>
<span class="sd">        :attr:`~geonat.models.Model.active_parameters`.</span>

<span class="sd">        Only valid parameters will be used by :meth:`~geonat.models.Model.get_mapping` and</span>
<span class="sd">        :meth:`~geonat.models.Model.evaluate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zero_threshold : float, optional</span>
<span class="sd">            Model parameters with absolute values below ``zero_threshold`` will be</span>
<span class="sd">            set inactive. Defaults to ``1e-10``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        unfreeze : The reverse method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">float</span><span class="p">(</span><span class="n">zero_threshold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;&#39;zero_threshold needs to be non-negative, got </span><span class="si">{</span><span class="n">zero_threshold</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot freeze a model without set parameters.&quot;</span><span class="p">)</span>
        <span class="n">temp_par</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scaling</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp_par</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ix_params</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span><span class="p">[</span><span class="n">ix_params</span><span class="p">:</span><span class="n">ix_params</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">]</span>
            <span class="n">ix_params</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span></div>

<div class="viewcode-block" id="SplineSet.unfreeze"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.SplineSet.unfreeze">[docs]</a>    <span class="k">def</span> <span class="nf">unfreeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets previous model freezing done by :meth:`~freeze` such that all parameters</span>
<span class="sd">        are active again.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">active_parameters</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SplineSet.read_parameters"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.SplineSet.read_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">read_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads in the parameters :math:`\mathbf{m}` (optionally also their variances)</span>
<span class="sd">        of all the sub-splines and stores them in the respective attributes.</span>

<span class="sd">        Note that the main ``SplineSet`` object will still contain all the cross-spline</span>
<span class="sd">        covariances (if contained in ``covariances``), but the sub-splines cannot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : numpy.ndarray</span>
<span class="sd">            Model parameters of shape</span>
<span class="sd">            :math:`(\text{num_parameters}, \text{num_components})`.</span>
<span class="sd">        covariances : numpy.ndarray, optional</span>
<span class="sd">            Model component (co-)variances that can either have the same shape as</span>
<span class="sd">            ``parameters``, in which case every parameter and component only has a</span>
<span class="sd">            variance, or it is square with dimensions</span>
<span class="sd">            :math:`\text{num_parameters} * \text{num_components}`, in which case it</span>
<span class="sd">            represents a full variance-covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">read_parameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">covariances</span><span class="p">)</span>
        <span class="n">num_components</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scaling</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">covariances</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parameters</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">covariances</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">covariances</span> <span class="o">=</span> <span class="n">covariances</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">repeat_int_scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span><span class="p">,</span> <span class="n">num_components</span><span class="p">)</span>
                    <span class="n">covariances</span> <span class="o">=</span> <span class="p">((</span><span class="n">covariances</span> <span class="o">*</span> <span class="n">repeat_int_scales</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                                   <span class="o">*</span> <span class="n">repeat_int_scales</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ix_params</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">:</span>
            <span class="n">param_model</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">ix_params</span><span class="p">:</span><span class="n">ix_params</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">covariances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cov_model</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">parameters</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">covariances</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">cov_model</span> <span class="o">=</span> <span class="n">covariances</span><span class="p">[</span><span class="n">ix_params</span><span class="p">:</span><span class="n">ix_params</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ix_start</span> <span class="o">=</span> <span class="n">ix_params</span> <span class="o">*</span> <span class="n">num_components</span>
                <span class="n">ix_end</span> <span class="o">=</span> <span class="n">ix_start</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">*</span> <span class="n">num_components</span>
                <span class="n">cov_model</span> <span class="o">=</span> <span class="n">covariances</span><span class="p">[</span><span class="n">ix_start</span><span class="p">:</span><span class="n">ix_end</span><span class="p">,</span> <span class="n">ix_start</span><span class="p">:</span><span class="n">ix_end</span><span class="p">]</span>
            <span class="n">model</span><span class="o">.</span><span class="n">read_parameters</span><span class="p">(</span><span class="n">param_model</span><span class="p">,</span> <span class="n">cov_model</span><span class="p">)</span>
            <span class="n">ix_params</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span></div>

<div class="viewcode-block" id="SplineSet.make_scalogram"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.SplineSet.make_scalogram">[docs]</a>    <span class="k">def</span> <span class="nf">make_scalogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_left</span><span class="p">,</span> <span class="n">t_right</span><span class="p">,</span> <span class="n">cmaprange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                       <span class="n">min_param_mag</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a scalogram figure of the model parameters.</span>

<span class="sd">        A scalogram shows the amplitude of each model parameter plotted over time and</span>
<span class="sd">        for all the different scales contained. Model parameters that have overlapping</span>
<span class="sd">        influence are also shown as overlapping. The height of each parameter&#39;s patch</span>
<span class="sd">        is defined by the weight of that parameter relative to the other parameters</span>
<span class="sd">        (excluding splines that are not transient at that time).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t_left : str</span>
<span class="sd">            Left boundary of the time axis.</span>
<span class="sd">        t_right : str</span>
<span class="sd">            Right boundary of the time axis.</span>
<span class="sd">        cmaprange : float or int, optional</span>
<span class="sd">            Maximum absolute amplitude of the color scale to use.</span>
<span class="sd">            Defaults to the 95th percentile of the absolute amplitudes of all parameters.</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of points inside the time span to evaluate the scalogram at.</span>
<span class="sd">        min_param_mag : float, optional</span>
<span class="sd">            The absolute value under which any value is plotted as zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            Figure object of the scalogram.</span>
<span class="sd">        ax : matplotlib.axes.Axes</span>
<span class="sd">            Axes object of the scalogram.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the generation method for the scalogram given the SplineSet&#39;s</span>
<span class="sd">            spline class is not defined in this method yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check input</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;SplineSet model needs to have already been fitted.&quot;</span><span class="p">)</span>
        <span class="c1"># determine dimensions</span>
        <span class="n">num_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_scales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">)</span>
        <span class="n">dy_scale</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">num_scales</span>
        <span class="n">t_plot</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">t_left</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">t_right</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">resolution</span><span class="p">))</span>
        <span class="c1"># get range of values (if not provided)</span>
        <span class="k">if</span> <span class="n">cmaprange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmaprange</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmaprange</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> \
                <span class="s2">&quot;&#39;cmaprange&#39; must be None or a single float or integer of the &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;one-sided color range of the scalogram, got </span><span class="si">{</span><span class="n">cmaprange</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmaprange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">par</span><span class="p">)</span>
                                               <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">],</span>
                                              <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">scm</span><span class="o">.</span><span class="n">roma_r</span><span class="p">,</span>
                                     <span class="n">norm</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">cmaprange</span><span class="p">,</span>
                                                               <span class="n">vmax</span><span class="o">=</span><span class="n">cmaprange</span><span class="p">))</span>
        <span class="c1"># get heights of component axes that leaves room for colorbar</span>
        <span class="n">row_hr</span> <span class="o">=</span> <span class="mf">0.95</span> <span class="o">/</span> <span class="n">num_components</span>
        <span class="n">height_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">row_hr</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_components</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">]</span>
        <span class="c1"># start plotting</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="n">num_components</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;height_ratios&quot;</span><span class="p">:</span> <span class="n">height_ratios</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">):</span>
            <span class="c1"># where to put this scale</span>
            <span class="n">y_off</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dy_scale</span>
            <span class="c1"># get normalized values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">splineclass</span> <span class="o">==</span> <span class="n">BSpline</span><span class="p">:</span>
                <span class="n">mdl_mapping</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">t_plot</span><span class="p">,</span> <span class="n">ignore_active_parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">splineclass</span> <span class="o">==</span> <span class="n">ISpline</span><span class="p">:</span>
                <span class="n">mdl_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">t_plot</span><span class="p">,</span> <span class="n">ignore_active_parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Scalogram undefined for a SplineSet of class &quot;</span>
                                          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">splineclass</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">mdl_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mdl_mapping</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mdl_sum</span><span class="p">[</span><span class="n">mdl_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">y_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">t_plot</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mdl_mapping</span> <span class="o">/</span> <span class="n">mdl_sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>
            <span class="c1"># plot cell</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_components</span><span class="p">)):</span>
                <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">par</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]):</span>
                    <span class="n">facecol</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">par</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                                           <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">par</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">min_param_mag</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">t_plot</span><span class="p">,</span>
                                       <span class="n">y_off</span> <span class="o">+</span> <span class="n">y_norm</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">dy_scale</span><span class="p">,</span>
                                       <span class="n">y_off</span> <span class="o">+</span> <span class="n">y_norm</span><span class="p">[:,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dy_scale</span><span class="p">,</span>
                                       <span class="n">facecolor</span><span class="o">=</span><span class="n">facecol</span><span class="p">)</span>
            <span class="c1"># plot vertical lines at centerpoints</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_components</span><span class="p">)):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">t_reference</span>
                              <span class="o">+</span> <span class="n">Timedelta</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">time_unit</span><span class="p">),</span>
                              <span class="n">y_off</span><span class="p">,</span> <span class="n">y_off</span> <span class="o">+</span> <span class="n">dy_scale</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;0.5&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="c1"># finish plot by adding relevant gridlines and labels</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_components</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_scales</span><span class="p">):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dy_scale</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;0.5&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">t_left</span><span class="p">,</span> <span class="n">t_right</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">dy_scale</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_scales</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">dy_scale</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_scales</span><span class="p">)],</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="nb">reversed</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">scale</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">time_unit</span><span class="si">}</span><span class="s2">&quot;</span>
                                           <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splines</span><span class="p">]),</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;minor&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
                     <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Coefficient Value&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div></div>


<div class="viewcode-block" id="Sinusoidal"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Sinusoidal">[docs]</a><span class="k">class</span> <span class="nc">Sinusoidal</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    This model provides a sinusoidal of a fixed period, with amplitude and phase</span>
<span class="sd">    to be fitted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    period : float</span>
<span class="sd">        Period length in :attr:`~geonat.models.Model.time_unit` units.</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Implements the relationship</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{g}(\mathbf{t}) =</span>
<span class="sd">        a \cos ( 2 \pi \mathbf{t} / T ) + b \sin ( 2 \pi \mathbf{t} / T )</span>

<span class="sd">    with :attr:`~period` :math:`T`, :attr:`~phase` :math:`\phi=\text{atan2}(b,a)`</span>
<span class="sd">    and :attr:`~amplitude` :math:`A=\sqrt{a^2 + b^2}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span>
                         <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Period of the sinusoid. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Sinusoidal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Amplitude of the sinusoid. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot evaluate the model before reading in parameters.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Phase of the sinusoid. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot evaluate the model before reading in parameters.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Logarithmic"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Logarithmic">[docs]</a><span class="k">class</span> <span class="nc">Logarithmic</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    This model provides the &quot;geophysical&quot; logarithmic :math:`\ln(1 + \mathbf{t}/\tau)`</span>
<span class="sd">    with a given time constant and zero for :math:`\mathbf{t} &lt; 0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tau : float</span>
<span class="sd">        Logarithmic time constant :math:`\tau`.</span>
<span class="sd">        It represents the time at which, after zero-crossing at the reference</span>
<span class="sd">        time, the logarithm reaches the value 1 (before model scaling).</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span>
                 <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t_start</span> <span class="o">=</span> <span class="n">t_reference</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span>
                         <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="n">zero_after</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> \
            <span class="s2">&quot;Logarithmic model has to have valid bounds, but the reference time &quot;</span> <span class="o">+</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">t_reference_str</span><span class="si">}</span><span class="s2"> is after the start time </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">t_start_str</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Logarithmic time constant. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Logarithmic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span></div>


<div class="viewcode-block" id="Exponential"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Exponential">[docs]</a><span class="k">class</span> <span class="nc">Exponential</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    This model provides the &quot;geophysical&quot; exponential :math:`1-\exp(-\mathbf{t}/\tau)`</span>
<span class="sd">    with a given time constant, zero for :math:`\mathbf{t} &lt; 0`, and approaching</span>
<span class="sd">    one asymptotically.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tau : float</span>
<span class="sd">        Exponential time constant :math:`\tau`.</span>
<span class="sd">        It represents the amount of time that it takes for the (general) exponential</span>
<span class="sd">        function&#39;s value to be multiplied by :math:`e`.</span>
<span class="sd">        Applied to this model, for a given relative amplitude :math:`a` (so :math:`0 &lt; a &lt; 1`,</span>
<span class="sd">        before model scaling) to be reached at given :math:`\Delta t` past ``t_start``,</span>
<span class="sd">        :math:`\tau = - \frac{\Delta t}{\ln(1 - a)}`</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span>
                 <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t_start</span> <span class="o">=</span> <span class="n">t_reference</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span>
                         <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="n">zero_after</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_reference</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> \
            <span class="s2">&quot;Exponential model has to have valid bounds, but the reference time &quot;</span> <span class="o">+</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">t_reference_str</span><span class="si">}</span><span class="s2"> is after the start time </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">t_start_str</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Exponential time constant. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Exponential&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coefs</span></div>


<div class="viewcode-block" id="Arctangent"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.Arctangent">[docs]</a><span class="k">class</span> <span class="nc">Arctangent</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses :class:`~geonat.models.Model`.</span>

<span class="sd">    This model provides the arctangent :math:`\arctan(\mathbf{t}/\tau)`,</span>
<span class="sd">    stretched with a given time constant and normalized to be between</span>
<span class="sd">    :math:`(0, 1)` at the limits.</span>

<span class="sd">    Because this model is usually transient, it is recommended not to</span>
<span class="sd">    use it in the estimation of parameters, even when using ``t_start``</span>
<span class="sd">    and ``t_end`` to make the tails constant (since that introduces high-frequency</span>
<span class="sd">    artifacts). (Using ``t_start`` and/or ``t_end`` might be desirable for creating</span>
<span class="sd">    syntehtic data, however.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tau : float</span>
<span class="sd">        Arctangent time constant :math:`\tau`.</span>
<span class="sd">        It represents the time at which, after zero-crossing at the reference</span>
<span class="sd">        time, the arctangent reaches the value :math:`\pi/4` (before model scaling),</span>
<span class="sd">        i.e. half of the one-sided amplitude.</span>


<span class="sd">    See :class:`~geonat.models.Model` for attribute descriptions and more keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">t_reference</span><span class="p">,</span>
                 <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">zero_before</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parameters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">t_reference</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="n">time_unit</span><span class="p">,</span>
                         <span class="n">zero_before</span><span class="o">=</span><span class="n">zero_before</span><span class="p">,</span> <span class="n">zero_after</span><span class="o">=</span><span class="n">zero_after</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Arctangent time constant. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Arctangent&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kw_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">timevector</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">coefs</span></div>


<div class="viewcode-block" id="check_model_dict"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.check_model_dict">[docs]</a><span class="k">def</span> <span class="nf">check_model_dict</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether a dictionary has the appropriate structure to be used to</span>
<span class="sd">    create :class:`~Model` objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    models : dict</span>
<span class="sd">        Dictionary of structure ``{model_name: {&quot;type&quot;: modelclass, &quot;kw_args&quot;:</span>
<span class="sd">        {**kw_args}}}`` that contains the names, types and necessary keyword arguments</span>
<span class="sd">        to create each model object.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the dictionary structure is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s2">&quot;&#39;models&#39; input needs to be a dictionary, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">models</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mdl_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">mdl_name</span> <span class="ow">in</span> <span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">()]),</span> \
        <span class="sa">f</span><span class="s2">&quot;Model names need to be strings, got </span><span class="si">{</span><span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mdl_config</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">mdl_config</span> <span class="ow">in</span> <span class="n">models</span><span class="o">.</span><span class="n">values</span><span class="p">()]),</span> \
        <span class="sa">f</span><span class="s2">&quot;Model configurations need to be dictionaries, got </span><span class="si">{</span><span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">for</span> <span class="n">mdl_name</span><span class="p">,</span> <span class="n">mdl_config</span> <span class="ow">in</span> <span class="n">models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">key</span> <span class="ow">in</span> <span class="n">mdl_config</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;kw_args&quot;</span><span class="p">]]),</span> \
            <span class="sa">f</span><span class="s2">&quot;The configuration dictionary for &#39;</span><span class="si">{</span><span class="n">mdl_name</span><span class="si">}</span><span class="s2">&#39; needs to contain &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;the keys &#39;type&#39; and &#39;kw_args&#39;, got </span><span class="si">{</span><span class="n">mdl_config</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mdl_config</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;&#39;type&#39; in configuration dictionary for &#39;</span><span class="si">{</span><span class="n">mdl_name</span><span class="si">}</span><span class="s2">&#39; needs to be &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;a string, got </span><span class="si">{</span><span class="n">mdl_config</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mdl_config</span><span class="p">[</span><span class="s2">&quot;kw_args&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;&#39;kw_args&#39; in configuration dictionary for &#39;</span><span class="si">{</span><span class="n">mdl_name</span><span class="si">}</span><span class="s2">&#39; needs to be &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;a dictionary, got </span><span class="si">{</span><span class="n">mdl_config</span><span class="p">[</span><span class="s1">&#39;kw_args&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span></div>


<span class="c1"># make a custom object that serves as the &quot;all models&quot; fit key</span>
<div class="viewcode-block" id="AllFits"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.AllFits">[docs]</a><span class="k">class</span> <span class="nc">AllFits</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Model&quot;</span></div>


<span class="c1"># this object is hashable, and we will create one instance that users can import</span>
<span class="n">ALLFITS</span> <span class="o">=</span> <span class="n">AllFits</span><span class="p">()</span>


<div class="viewcode-block" id="ModelCollection"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection">[docs]</a><span class="k">class</span> <span class="nc">ModelCollection</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that contains :class:`~Model` objects and is mainly used to keep track</span>
<span class="sd">    of across-model variables and relations such as the cross-model covariances.</span>
<span class="sd">    It also contains convenience functions that wrap individual models&#39; functions like</span>
<span class="sd">    :meth:`~geonat.models.Model.evaluate`, :meth:`~geonat.models.Model.get_mapping`</span>
<span class="sd">    or :meth:`~geonat.models.Model.read_parameters` or attributes like</span>
<span class="sd">    :attr:`~geonat.models.Model.par`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EVAL_PREDVAR_PRECISION</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To reduce memory impact when estimating the full covariance of the predicted</span>
<span class="sd">    timeseries when calling :meth:`~evaluate`, this attribute is by default set to</span>
<span class="sd">    single precision, but can be changed to double precision if desired.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of :class:`~Model` objects contained in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ModelCollection.from_model_dict"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.from_model_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_model_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an empty :class:`~ModelCollection` object, and adds a dictionary of</span>
<span class="sd">        model objects to it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_dict : dict</span>
<span class="sd">            Dictionary with model names as keys, and :class:`~Model` object instances</span>
<span class="sd">            as values.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        ModelCollection</span>
<span class="sd">            The new :class:`~ModelCollection` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coll</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">model_description</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">model_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">coll</span><span class="p">[</span><span class="n">model_description</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">return</span> <span class="n">coll</span></div>

<div class="viewcode-block" id="ModelCollection.__getitem__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience special function to the models contained in :attr:`~collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model_description</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No model &#39;</span><span class="si">{</span><span class="n">model_description</span><span class="si">}</span><span class="s2">&#39; present in collection.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">model_description</span><span class="p">]</span></div>

<div class="viewcode-block" id="ModelCollection.__setitem__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_description</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience special function to add or update a model contained in</span>
<span class="sd">        :attr:`~collection`. Setting or updating a model forces the collection&#39;s</span>
<span class="sd">        parameter and covariance matrices to be reset to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_description</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">Model</span><span class="p">),</span> \
            <span class="s2">&quot;&#39;model_description&#39; needs to be a string and &#39;model&#39; needs to be a Model, &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">model_description</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="n">model_description</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ModelCollection: Overwriting model &#39;</span><span class="si">{</span><span class="n">model_description</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">,</span>
                 <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">model_description</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span></div>

<div class="viewcode-block" id="ModelCollection.__delitem__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__delitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience special function to delete a model contained in</span>
<span class="sd">        :attr:`~collection`. Deleting a model forces the collection&#39;s parameter and</span>
<span class="sd">        covariance matrices to be reset to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">model_description</span><span class="p">]</span></div>

<div class="viewcode-block" id="ModelCollection.__iter__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience special function that allows for a shorthand notation to quickly</span>
<span class="sd">        iterate over all models in :attr:`~collection`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        If ``mc`` is a :class:`~ModelCollection` instance, then the following</span>
<span class="sd">        two loops are equivalent::</span>

<span class="sd">            # long version</span>
<span class="sd">            for model in mc.collection.values():</span>
<span class="sd">                pass</span>
<span class="sd">            # shorthand</span>
<span class="sd">            for model in mc:</span>
<span class="sd">                pass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">model</span></div>

<div class="viewcode-block" id="ModelCollection.__len__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function that gives quick access to the number of models</span>
<span class="sd">        in the collection using Python&#39;s built-in ``len()`` function</span>
<span class="sd">        to make interactions with iterators easier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">)</span></div>

<div class="viewcode-block" id="ModelCollection.__contains__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function that allows to check whether a certain model description</span>
<span class="sd">        is in the collection.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        If ``mc`` is a :class:`~ModelCollection` instance, and we want to check whether</span>
<span class="sd">        ``&#39;mymodel&#39;`` is a model in the collection, the following two are equivalent::</span>

<span class="sd">            # long version</span>
<span class="sd">            &#39;mymodel&#39; in mc.collection</span>
<span class="sd">            # short version</span>
<span class="sd">            &#39;mymodel&#39; in mc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">model_description</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span></div>

<div class="viewcode-block" id="ModelCollection.__str__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function that returns a readable summary of the model collection.</span>
<span class="sd">        Accessed, for example, by Python&#39;s ``print()`` built-in function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        info : str</span>
<span class="sd">            Model collection summary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ModelCollection (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="si">}</span><span class="s2"> parameters)&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="s1">&#39;:&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}{</span><span class="n">v</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="ModelCollection.__eq__"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function that allows for the comparison of model collection based on</span>
<span class="sd">        their contents, regardless of model parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geonat.models.ModelCollection</span>
<span class="sd">            Model collection to compare to.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        geonat.models.Model.__eq__ : For more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()</span></div>

<div class="viewcode-block" id="ModelCollection.get_arch"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.get_arch">[docs]</a>    <span class="k">def</span> <span class="nf">get_arch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary that describes the model collection fully and allows it to</span>
<span class="sd">        be recreated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arch : dict</span>
<span class="sd">            Model keyword dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ModelCollection&quot;</span><span class="p">,</span>
                <span class="s2">&quot;collection&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">get_arch</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">items</span><span class="p">()}}</span>
        <span class="k">return</span> <span class="n">arch</span></div>

<div class="viewcode-block" id="ModelCollection.items"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function that returns a key-value-iterator from :attr:`~collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of parameters in the model collection, calculated as the sum of all</span>
<span class="sd">        the parameters in the contained models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">num_parameters</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of all model names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of all regularized parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regularized_mask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">regularized_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean array mask of shape :math:`(\text{num_parameters}, )`</span>
<span class="sd">        where ``True`` denotes a regularized parameter (``False`` otherwise``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regularized_mask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">regularized_mask</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">regularize</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">regularized_mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">internal_scales</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array of shape :math:`(\text{num_parameters}, )` that collects all the</span>
<span class="sd">        models&#39; internal scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">internal_scales</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">internal_scales</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;internal_scales&quot;</span><span class="p">,</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">internal_scales</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">active_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Either ``None``, if all parameters are active, or an array of shape</span>
<span class="sd">        :math:`(\text{num_parameters}, )` that contains ``True`` for all active</span>
<span class="sd">        parameters, and ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">active_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">active_parameters</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">active_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                             <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="n">active_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">active_params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">active_params</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">active_params</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">par</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array property of shape :math:`(\text{num_parameters}, \text{num_components})`</span>
<span class="sd">        that contains the parameters as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">test_par</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">par</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">test_par_anynone</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">test_par</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">test_par_anynone</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Discrepancy between ModelCollection parameters and individual &quot;</span>
                 <span class="s2">&quot;parameters: collection is not fitted.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> \
                <span class="s2">&quot;Saved parameter matrix does not match the model list in the collection.&quot;</span>
            <span class="k">if</span> <span class="n">test_par_anynone</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Discrepancy between ModelCollection parameters and individual &quot;</span>
                     <span class="s2">&quot;parameters: individual models are not fitted.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">test_par</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">test_par</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">,</span> <span class="n">test_par</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Discrepancy between ModelCollection parameters and individual &quot;</span>
                         <span class="s2">&quot;parameters: not matching (returning collection values).&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Alias for :attr:`~par`. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array property of shape :math:`(\text{num_parameters}, \text{num_components})`</span>
<span class="sd">        that returns the parameter&#39;s individual variances as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Square array property with dimensions</span>
<span class="sd">        :math:`\text{num_elements} * \text{num_components}` that contains the parameter&#39;s</span>
<span class="sd">        full covariance matrix as a NumPy array. The rows (and columns) are ordered such</span>
<span class="sd">        that they first correspond to the covariances between all components for the first</span>
<span class="sd">        parameter, then the covariance between all components for the second parameter,</span>
<span class="sd">        and so forth.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">test_cov</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">cov</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">test_cov_anynone</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">test_cov</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">test_cov_anynone</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Discrepancy between ModelCollection covariance and individual &quot;</span>
                 <span class="s2">&quot;covariances: collection is not fitted.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">par_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">par_size</span><span class="p">,</span> <span class="n">par_size</span><span class="p">),</span> \
                <span class="s2">&quot;Saved covariance matrix does not match the model list in the collection.&quot;</span>
            <span class="k">if</span> <span class="n">test_cov_anynone</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Discrepancy between ModelCollection covariance and individual &quot;</span>
                     <span class="s2">&quot;covariances: individual models are not fitted.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">test_cov</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">test_cov</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">test_cov_nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">test_cov</span><span class="p">)</span>
                <span class="n">test_cov</span> <span class="o">=</span> <span class="n">test_cov</span><span class="p">[</span><span class="n">test_cov_nonzero</span><span class="p">]</span>
                <span class="n">cov_nooffdiag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">test_cov_nonzero</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cov_nooffdiag</span><span class="p">,</span> <span class="n">test_cov</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Discrepancy between ModelCollection covariance and individual &quot;</span>
                         <span class="s2">&quot;covariance: not matching (returning collection values).&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">covariances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Alias for :attr:`~cov`. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span>

<div class="viewcode-block" id="ModelCollection.freeze"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.freeze">[docs]</a>    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_threshold</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function that calls :meth:`~geonat.models.Model.freeze` for all</span>
<span class="sd">        models (or a subset thereof) contained in the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_list : list, optional</span>
<span class="sd">            If ``None`` (default), freeze all models. If a list of strings, only</span>
<span class="sd">            freeze the corresponding models in the collection.</span>
<span class="sd">        zero_threshold : float, optional</span>
<span class="sd">            Model parameters with absolute values below ``zero_threshold`` will be</span>
<span class="sd">            set to zero and set inactive. Defaults to ``1e-10``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mdl</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">mdl</span> <span class="ow">in</span> <span class="n">model_list</span><span class="p">])),</span> \
                <span class="sa">f</span><span class="s2">&quot;&#39;model_list&#39; needs to be a list of strings, got </span><span class="si">{</span><span class="n">model_list</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mdl</span> <span class="k">for</span> <span class="n">mdl_description</span><span class="p">,</span> <span class="n">mdl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                      <span class="k">if</span> <span class="p">(</span><span class="n">model_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mdl_description</span> <span class="ow">in</span> <span class="n">model_list</span><span class="p">)]:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">freeze</span><span class="p">(</span><span class="n">zero_threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="ModelCollection.unfreeze"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.unfreeze">[docs]</a>    <span class="k">def</span> <span class="nf">unfreeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function that calls :meth:`~geonat.models.Model.unfreeze` for all</span>
<span class="sd">        models (or a subset thereof) contained in the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_list : list, optional</span>
<span class="sd">            If ``None`` (default), unfreeze all models. If a list of strings, only</span>
<span class="sd">            unfreeze the corresponding models in the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mdl</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">mdl</span> <span class="ow">in</span> <span class="n">model_list</span><span class="p">])),</span> \
                <span class="sa">f</span><span class="s2">&quot;&#39;model_list&#39; needs to be a list of strings, got </span><span class="si">{</span><span class="n">model_list</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mdl</span> <span class="k">for</span> <span class="n">mdl_description</span><span class="p">,</span> <span class="n">mdl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                      <span class="k">if</span> <span class="p">(</span><span class="n">model_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mdl_description</span> <span class="ow">in</span> <span class="n">model_list</span><span class="p">)]:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">unfreeze</span><span class="p">()</span></div>

    <span class="c1"># &quot;inherit&quot; the read_parameter function from the Model class</span>
    <span class="n">_read_parameters</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">read_parameters</span>

<div class="viewcode-block" id="ModelCollection.read_parameters"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.read_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">read_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads in the entire collection&#39;s parameters :math:`\mathbf{m}` (optionally also</span>
<span class="sd">        their covariance) and stores them in the instance attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : numpy.ndarray</span>
<span class="sd">            Model collection parameters of shape</span>
<span class="sd">            :math:`(\text{num_parameters}, \text{num_components})`.</span>
<span class="sd">        covariances : numpy.ndarray, optional</span>
<span class="sd">            Model collection component (co-)variances that can either have the same shape</span>
<span class="sd">            as ``parameters``, in which case every parameter and component only has a</span>
<span class="sd">            variance, or it is square with dimensions</span>
<span class="sd">            :math:`\text{num_parameters} * \text{num_components}`, in which case it</span>
<span class="sd">            represents a full variance-covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read as if the collection was a model for itself</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_parameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">covariances</span><span class="p">)</span>
        <span class="c1"># distribute to models (they should get just sliced views of the full data)</span>
        <span class="n">ix_params</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># get parameters slice</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param_model</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">ix_params</span><span class="p">:</span><span class="n">ix_params</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># get covariance slice</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">cov_model</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ix_start</span> <span class="o">=</span> <span class="n">ix_params</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ix_end</span> <span class="o">=</span> <span class="n">ix_start</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cov_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="p">[</span><span class="n">ix_start</span><span class="p">:</span><span class="n">ix_end</span><span class="p">,</span> <span class="n">ix_start</span><span class="p">:</span><span class="n">ix_end</span><span class="p">]</span>
            <span class="c1"># pass to model and advance</span>
            <span class="n">model</span><span class="o">.</span><span class="n">read_parameters</span><span class="p">(</span><span class="n">param_model</span><span class="p">,</span> <span class="n">cov_model</span><span class="p">)</span>
            <span class="n">ix_params</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span></div>

    <span class="c1"># &quot;inherit&quot; the evaluate function from the Model class</span>
    <span class="n">evaluate</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">evaluate</span>

<div class="viewcode-block" id="ModelCollection.get_mapping"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.get_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timevector</span><span class="p">,</span> <span class="n">return_observability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">ignore_active_parameters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the mapping matrix :math:`\mathbf{G}` given a time vector :math:`\mathbf{t}`</span>
<span class="sd">        by concatenating the individual mapping matrices from each contained model using</span>
<span class="sd">        their method :meth:`~geonat.models.Model.get_mapping` (see for more details).</span>

<span class="sd">        This method respects the parameters being set invalid by :meth:`~freeze`, and will</span>
<span class="sd">        interpret those parameters to be unobservable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timevector : pandas.Series, pandas.DatetimeIndex</span>
<span class="sd">            :class:`~pandas.Series` of :class:`~pandas.Timestamp` or alternatively a</span>
<span class="sd">            :class:`~pandas.DatetimeIndex` containing the timestamps of each observation.</span>
<span class="sd">        return_observability : bool, optional</span>
<span class="sd">            If true, the function will check if there are any all-zero columns, which</span>
<span class="sd">            would point to unobservable parameters, and return a boolean mask with the</span>
<span class="sd">            valid indices.</span>
<span class="sd">        ignore_active_parameters : bool, optional</span>
<span class="sd">            If ``True``, do not set inactive parameters to zero to avoid estimation.</span>
<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mapping : scipy.sparse.csc_matrix</span>
<span class="sd">            Sparse mapping matrix.</span>
<span class="sd">        observable : numpy.ndarray</span>
<span class="sd">            Returned if ``return_observability=True``.</span>
<span class="sd">            A boolean NumPy array of the same length as ``mapping`` has columns.</span>
<span class="sd">            ``False`` indicates (close to) all-zero columns (unobservable parameters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mappings</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">timevector</span><span class="p">,</span>
                                  <span class="n">return_observability</span><span class="o">=</span><span class="n">return_observability</span><span class="p">,</span>
                                  <span class="n">ignore_active_parameters</span><span class="o">=</span><span class="n">ignore_active_parameters</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_observability</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mappings</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
            <span class="n">observable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mappings</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">observable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">mappings</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mapping</span></div>

<div class="viewcode-block" id="ModelCollection.prepare_LS"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.prepare_LS">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_LS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">include_regularization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reweight_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">use_internal_scales</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that concatenates the mapping matrices of the collection</span>
<span class="sd">        models given the timevector in in the input timeseries, and returns some</span>
<span class="sd">        relevant sizes.</span>

<span class="sd">        It can also combine the regularization masks and reshape the input weights</span>
<span class="sd">        into the format used by the solvers, optionally taking into account</span>
<span class="sd">        the internal scales.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : geonat.timeseries.Timeseries</span>
<span class="sd">            The timeseries whose time indices are used to calculate the mapping matrix.</span>
<span class="sd">        include_regularization : bool, optional</span>
<span class="sd">            If ``True`` (default), expands the returned variables (see below) and computes</span>
<span class="sd">            the regularization mask for the observable parameters only.</span>
<span class="sd">        reweight_init : numpy.ndarray, dict, list, optional</span>
<span class="sd">            Contains the initial weights for the current iteration of the least squares</span>
<span class="sd">            problem. It can be a Numpy array or a list of Numpy arrays, in which case it</span>
<span class="sd">            (or the array created by concatenating the list) need to already have the right</span>
<span class="sd">            output shape (no check is performed). If it is a dictionary, the keys need to be</span>
<span class="sd">            model names, and the values are then the Numpy arrays which will be arranged</span>
<span class="sd">            properly to match the mapping matrix.</span>
<span class="sd">        use_internal_scales : bool, optional</span>
<span class="sd">            If ``True`` (default: ``False``), also return the internal model scales,</span>
<span class="sd">            subset to the observable and regularized parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : scipy.sparse.spmatrix</span>
<span class="sd">            Mapping matrix computed by :meth:`~get_mapping`.</span>
<span class="sd">        obs_mask : numpy.ndarray</span>
<span class="sd">            Observability mask computed by :meth:`~get_mapping`.</span>
<span class="sd">        num_time : int</span>
<span class="sd">            Length of the timeseries.</span>
<span class="sd">        num_params : int</span>
<span class="sd">            Number of total parameters present in the model collection.</span>
<span class="sd">        num_comps : int</span>
<span class="sd">            Number of components in the timeseries.</span>
<span class="sd">        num_obs : int</span>
<span class="sd">            Number of observable parameters.</span>
<span class="sd">        num_reg : int</span>
<span class="sd">            (Only if ``include_regularization=True``.)</span>
<span class="sd">            Number of observable and regularized parameters.</span>
<span class="sd">        reg_mask : numpy.ndarray</span>
<span class="sd">            (Only if ``include_regularization=True``.)</span>
<span class="sd">            Numpy array of shape :math:`(\text{num_obs}, )` that for each observable</span>
<span class="sd">            parameter denotes whether that parameter is regularized (``True``) or not.</span>
<span class="sd">        init_weights : numpy.ndarray</span>
<span class="sd">            (Only if ``include_regularization=True``.)</span>
<span class="sd">            Numpy array of shape :math:`(\text{num_reg}, )` that for each observable</span>
<span class="sd">            and regularized parameter contains the initial weights.</span>
<span class="sd">            ``None`` if ``reweight_init=None``.</span>
<span class="sd">        weights_scaling : numpy.ndarray</span>
<span class="sd">            (Only if ``include_regularization=True``.)</span>
<span class="sd">            Numpy array of shape :math:`(\text{num_reg}, )` that for each observable</span>
<span class="sd">            and regularized parameter contains the internal model scale.</span>
<span class="sd">            ``None`` if ``use_internal_scales=False``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        build_LS : Function that follows this one in the regular solving process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># G has shape (ts.time.size, self.num_parameters)</span>
        <span class="c1"># obs_mask has shape (self.num_parameters, ) and is True if a parameter</span>
        <span class="c1"># is observable</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">obs_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">return_observability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_time</span><span class="p">,</span> <span class="n">num_params</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">num_params</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Mapping matrix is empty, has shape </span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="n">num_obs</span> <span class="o">=</span> <span class="n">obs_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">num_obs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Mapping matrix has no observable parameters.&quot;</span>
        <span class="n">num_comps</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_components</span>
        <span class="k">if</span> <span class="n">include_regularization</span><span class="p">:</span>
            <span class="c1"># reg_mask_full has shape (self.num_parameters, ) and is True if</span>
            <span class="c1"># a parameter should be regularized</span>
            <span class="n">reg_mask_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularized_mask</span>
            <span class="c1"># now, we need the regularization mask reg_mask for the reduced G matrix, which</span>
            <span class="c1"># will only contain observable columns, has therefore shape (sum(obs_mask), )</span>
            <span class="n">reg_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reg_mask_full</span><span class="p">)[</span><span class="n">obs_mask</span><span class="p">]</span>
            <span class="c1"># sum_reg is the number of parameters that are both observable and regularized</span>
            <span class="n">num_reg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">reg_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_reg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Regularized solver got no models to regularize.&quot;</span><span class="p">)</span>
            <span class="c1"># if use_internal_scales, we still need the scales for all the observable and</span>
            <span class="c1"># regularized parameters</span>
            <span class="c1"># self.internal_scales has shape (self.num_parameters, ) so we can use the</span>
            <span class="c1"># combination of obs_mask and reg_mask_full to find the relevant subset</span>
            <span class="k">if</span> <span class="n">use_internal_scales</span><span class="p">:</span>
                <span class="n">weights_scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_scales</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">reg_mask_full</span><span class="p">,</span> <span class="n">obs_mask</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights_scaling</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># if there are initial weights, distribute those</span>
            <span class="k">if</span> <span class="n">reweight_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">init_weights</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reweight_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">init_weights</span> <span class="o">=</span> <span class="n">reweight_init</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reweight_init</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">init_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">init_weights</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reweight_init</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># concatenace the sub-arrays in the right order, and fill with empty</span>
                <span class="c1"># weights (temporarily) in between, so that we can use the global obs_mask</span>
                <span class="n">init_weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">mdl_description</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">regularize</span> <span class="ow">and</span> <span class="n">mdl_description</span> <span class="ow">in</span> <span class="n">reweight_init</span><span class="p">:</span>
                        <span class="n">init_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reweight_init</span><span class="p">[</span><span class="n">mdl_description</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">temp_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">))</span>
                        <span class="n">temp_weights</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                        <span class="n">init_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_weights</span><span class="p">)</span>
                <span class="n">init_weights</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">init_weights</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">reg_mask_full</span><span class="p">,</span> <span class="n">obs_mask</span><span class="p">)]</span>
                <span class="c1"># this should not contain any NaNs anymore</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">init_weights</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized input for &#39;reweight_init&#39;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">init_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">init_weights</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_reg</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">),</span> \
                    <span class="s2">&quot;The combined &#39;reweight_init&#39; must have the shape &quot;</span> <span class="o">+</span> \
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">num_reg</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">reweight_init</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">obs_mask</span><span class="p">,</span> <span class="n">num_time</span><span class="p">,</span> <span class="n">num_params</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">,</span> <span class="n">num_obs</span><span class="p">,</span> <span class="n">num_reg</span><span class="p">,</span> \
                <span class="n">reg_mask</span><span class="p">,</span> <span class="n">init_weights</span><span class="p">,</span> <span class="n">weights_scaling</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">obs_mask</span><span class="p">,</span> <span class="n">num_time</span><span class="p">,</span> <span class="n">num_params</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">,</span> <span class="n">num_obs</span></div>

<div class="viewcode-block" id="ModelCollection.build_LS"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.build_LS">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">build_LS</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">obs_mask</span><span class="p">,</span> <span class="n">icomp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_W_G</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">use_data_var</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_data_cov</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that builds the necessary matrices to solve the</span>
<span class="sd">        least-squares problem for the observable parameters given observations.</span>

<span class="sd">        If the problem only attempts to solve a single data component (by specifying</span>
<span class="sd">        its index in ``icomp``), it simply takes the input mapping matrix :math:`\mathbf{G}`,</span>
<span class="sd">        creates the weight matrix :math:`\mathbf{W}`, and computes</span>
<span class="sd">        :math:`\mathbf{G}^T \mathbf{W} \mathbf{G}` as well as</span>
<span class="sd">        :math:`\mathbf{G}^T \mathbf{W} \mathbf{d}`.</span>

<span class="sd">        If the problem is joint, i.e. there are multiple data components with covariance</span>
<span class="sd">        between them, this function brodcasts the mapping matrix to the components,</span>
<span class="sd">        creates the multi-component weight matrix, and then computes those same</span>
<span class="sd">        :math:`\mathbf{G}^T \mathbf{W} \mathbf{G}` and</span>
<span class="sd">        :math:`\mathbf{G}^T \mathbf{W} \mathbf{d}` matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : scipy.sparse.spmatrix</span>
<span class="sd">            Single-component mapping matrix.</span>
<span class="sd">        obs_mask: numpy.ndarray</span>
<span class="sd">            Observability mask.</span>
<span class="sd">        icomp : int, optional</span>
<span class="sd">            If provided, the integer index of the component of the data to be fitted.</span>
<span class="sd">        return_W_G : bool, optional</span>
<span class="sd">            If ``True`` (default: ``False``), also return the :math:`\mathbf{G}` and</span>
<span class="sd">            :math:`\mathbf{W}` matrices, reduced to the observable parameters and</span>
<span class="sd">            given observations.</span>
<span class="sd">        use_data_var : bool, optional</span>
<span class="sd">            If ``True`` (default), use the data variance if present. If ``False``,</span>
<span class="sd">            ignore it even if it is present.</span>
<span class="sd">        use_data_cov : bool, optional</span>
<span class="sd">            If ``True`` (default), use the data covariance if present. If ``False``,</span>
<span class="sd">            ignore it even if it is present.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : scipy.sparse.spmatrix</span>
<span class="sd">            (If ``return_W_G=True``.) Reduced :math:`\mathbf{G}` matrix.</span>
<span class="sd">        W : scipy.sparse.spmatrix</span>
<span class="sd">            (If ``return_W_G=True``.) Reduced :math:`\mathbf{W}` matrix.</span>
<span class="sd">        GtWG : numpy.ndarray</span>
<span class="sd">            Reduced :math:`\mathbf{G}^T \mathbf{W} \mathbf{G}` matrix.</span>
<span class="sd">        GtWd : numpy.ndarray</span>
<span class="sd">            Reduced :math:`\mathbf{G}^T \mathbf{W} \mathbf{d}` matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prepare_LS : Function that precedes this one in the regular solving process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_comps</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_components</span>
        <span class="k">if</span> <span class="n">icomp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">icomp</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">icomp</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_comps</span><span class="p">)),</span> \
                <span class="s2">&quot;&#39;icomp&#39; must be a valid integer component index (between 0 and &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_comps</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">), got </span><span class="si">{</span><span class="n">icomp</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="c1"># d and G are dense</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">data_cols</span><span class="p">[</span><span class="n">icomp</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dnotnan</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">Gout</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">dnotnan</span><span class="p">,</span> <span class="n">obs_mask</span><span class="p">)]</span>
            <span class="c1"># W is sparse</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">var_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_data_var</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">ts</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">var_cols</span><span class="p">[</span><span class="n">icomp</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">dnotnan</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dnotnan</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># d is dense, G and W are sparse</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dnotnan</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">Gout</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">G</span><span class="p">[:,</span> <span class="n">obs_mask</span><span class="p">],</span> <span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_comps</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dnotnan</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">dnotnan</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">Gout</span> <span class="o">=</span> <span class="n">Gout</span><span class="p">[</span><span class="n">dnotnan</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">cov_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_data_var</span> <span class="ow">and</span> <span class="n">use_data_cov</span><span class="p">:</span>
                <span class="n">var_cov_matrix</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">var_cov</span><span class="o">.</span><span class="n">values</span>
                <span class="n">Wblocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinvh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">var_cov_matrix</span><span class="p">[</span><span class="n">iobs</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">var_cov_map</span><span class="p">],</span>
                                                      <span class="p">(</span><span class="n">num_comps</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">)))</span>
                           <span class="k">for</span> <span class="n">iobs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_observations</span><span class="p">)]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="n">Wblocks</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
                <span class="n">W</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dnotnan</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">dnotnan</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">dnotnan</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()[:,</span> <span class="n">dnotnan</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">var_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_data_var</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">ts</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">dnotnan</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dnotnan</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">dnotnan</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">dnotnan</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># double-check</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Gout</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Still NaNs in G or W, unexpected error!&quot;</span><span class="p">)</span>
        <span class="c1"># everything here will be dense, except GtW when using data covariance</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">dnotnan</span><span class="p">]</span>
        <span class="n">GtW</span> <span class="o">=</span> <span class="n">Gout</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W</span>
        <span class="n">GtWG</span> <span class="o">=</span> <span class="n">GtW</span> <span class="o">@</span> <span class="n">Gout</span>
        <span class="n">GtWd</span> <span class="o">=</span> <span class="p">(</span><span class="n">GtW</span> <span class="o">@</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">GtWG</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="n">GtWG</span> <span class="o">=</span> <span class="n">GtWG</span><span class="o">.</span><span class="n">A</span>
        <span class="k">if</span> <span class="n">return_W_G</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Gout</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">GtWG</span><span class="p">,</span> <span class="n">GtWd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GtWG</span><span class="p">,</span> <span class="n">GtWd</span></div>

<div class="viewcode-block" id="ModelCollection.plot_covariance"><a class="viewcode-back" href="../../geonat/models.html#geonat.models.ModelCollection.plot_covariance">[docs]</a>    <span class="k">def</span> <span class="nf">plot_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_corr_coef</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plotting method that displays the covariance (or correlation coefficient) matrix.</span>
<span class="sd">        The axes are labeled by model names for easier interpretation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            If provided, the title that is added to the figure.</span>
<span class="sd">        fname : str, optional</span>
<span class="sd">            By default (``None``), the figure is shown interarctively to enable zooming in</span>
<span class="sd">            etc. If an ``fname`` is provided, the figure is instead directly saved to the</span>
<span class="sd">            provided filename.</span>
<span class="sd">        use_corr_coef : bool, optional</span>
<span class="sd">            By default (``False``), the method plots the covariance matrix.</span>
<span class="sd">            If ``True``, the correlation coefficient matrix is plotted instead.</span>
<span class="sd">        plot_empty : bool, optional</span>
<span class="sd">            By default (``True``), the full matrix is plotted. If it is sparse, it will be</span>
<span class="sd">            hard to identify the interplay between the different parameters. Therefore,</span>
<span class="sd">            setting ``plot_empty=False`` will only plot the rows and columns corresponding</span>
<span class="sd">            to nonzero parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a list of model names as well as the indices of the parameter boundaries</span>
        <span class="c1"># and the location of where to put the label</span>
        <span class="c1"># if a model is a spline collection, make the corresponding list entries another list</span>
        <span class="n">model_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boundary_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">label_centerpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">model_description</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">num_comps</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">SplineSet</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">plot_empty</span><span class="p">:</span>
                    <span class="n">model_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_description</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">scale</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">time_unit</span><span class="si">}</span><span class="s2">&quot;</span>
                                         <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">splines</span><span class="p">])</span>
                    <span class="n">bndrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">start_index</span><span class="p">]),</span>
                                            <span class="n">start_index</span> <span class="o">+</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">*</span> <span class="n">num_comps</span>
                                                       <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">splines</span><span class="p">])])</span>
                    <span class="n">boundary_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bndrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">boundary_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bndrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">cntrpts</span> <span class="o">=</span> <span class="p">(</span><span class="n">bndrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bndrs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">label_centerpoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cntrpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">start_index</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">*</span> <span class="n">num_comps</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">splines</span><span class="p">:</span>
                        <span class="n">mod_nonzero</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">cov</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">num_nonzero</span> <span class="o">=</span> <span class="n">mod_nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">num_nonzero</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">model_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_description</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">scale</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">time_unit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">boundary_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">num_nonzero</span><span class="p">)</span>
                            <span class="n">label_centerpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">num_nonzero</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                            <span class="n">start_index</span> <span class="o">+=</span> <span class="n">num_nonzero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">plot_empty</span><span class="p">:</span>
                    <span class="n">model_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model_description</span><span class="p">)</span>
                    <span class="n">boundary_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">*</span> <span class="n">num_comps</span><span class="p">)</span>
                    <span class="n">label_centerpoints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">boundary_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">boundary_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">start_index</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">num_parameters</span> <span class="o">*</span> <span class="n">num_comps</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mod_nonzero</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">cov</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">num_nonzero</span> <span class="o">=</span> <span class="n">mod_nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">num_nonzero</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">model_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model_description</span><span class="p">)</span>
                        <span class="n">boundary_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">num_nonzero</span><span class="p">)</span>
                        <span class="n">label_centerpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">num_nonzero</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">start_index</span> <span class="o">+=</span> <span class="n">num_nonzero</span>
        <span class="c1"># get whatever needs to be plotted</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_corr_coef</span><span class="p">:</span>  <span class="c1"># stick with covariance</span>
            <span class="n">cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_empty</span><span class="p">:</span>
                <span class="n">cov_mat_nonzero</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">cov_mat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">cov_mat_nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">start_index</span>
                <span class="n">cov_mat</span> <span class="o">=</span> <span class="n">cov_mat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">cov_mat_nonzero</span><span class="p">,</span> <span class="n">cov_mat_nonzero</span><span class="p">)]</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cov_mat</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="mi">95</span><span class="p">)</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">vmax</span>
            <span class="n">clabel</span> <span class="o">=</span> <span class="s2">&quot;Covariance&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cov_mat</span> <span class="o">=</span> <span class="n">cov2corr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_empty</span><span class="p">:</span>
                <span class="n">cov_mat_nonzero</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cov_mat</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">cov_mat_nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">start_index</span>
                <span class="n">cov_mat</span> <span class="o">=</span> <span class="n">cov_mat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">cov_mat_nonzero</span><span class="p">,</span> <span class="n">cov_mat_nonzero</span><span class="p">)]</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">clabel</span> <span class="o">=</span> <span class="s2">&quot;Correlation Coefficient&quot;</span>
        <span class="c1"># start the figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">cov_img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cov_mat</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">scm</span><span class="o">.</span><span class="n">roma</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
                            <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cov_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cov_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cov_img</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">clabel</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="c1"># give the major axis the calculated boundaries</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">boundary_indices</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([])</span>
        <span class="c1"># give the minor axis the labels</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">label_centerpoints</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">model_labels</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># give the y axis also the model name labels</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;major&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># do the same with the x axis, but with rotated labels</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">boundary_indices</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">label_centerpoints</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">model_labels</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;major&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># plot or save</span>
        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Tobias Khne.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>