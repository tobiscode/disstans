<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>disstans.processing &mdash; DISSTANS 2.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=1413ff29"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=f35be339"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/copybutton.js?v=c8c824eb"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation &amp; Updates</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#minimal-installation">Minimal installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#full-development-installation">Full development installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#updates">Updates</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_1.html">Tutorial 1: The first synthetic station</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#building-a-model-collection">Building a Model collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#creating-timeseries-objects">Creating Timeseries objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#fitting-the-models">Fitting the models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_1.html#plotting-the-fit-and-residuals">Plotting the fit and residuals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_2.html">Tutorial 2: Advanced Models and Fitting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#creating-more-complex-synthetic-data">Creating more complex synthetic data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#spline-models-for-transients">Spline models for transients</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#building-a-network">Building a Network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#fitting-an-entire-network">Fitting an entire network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#advanced-plotting">Advanced plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#repeat-with-l2-regularization">Repeat with L2 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#repeat-with-l1-regularization">Repeat with L1 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#repeat-with-l0-regularization">Repeat with L0 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_2.html#comparing-specific-parameters">Comparing specific parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_3.html">Tutorial 3: Incorporating Spatial Coherence</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#preparations">Preparations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#dreaming-up-a-network">Dreaming up a network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#fantasizing-data">Fantasizing data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#removing-the-common-mode-error">Removing the Common Mode Error</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#fitting-the-data-using-reweighted-l1-regularization">Fitting the data using reweighted L1 regularization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#fitting-the-data-using-a-spatially-aware-l1-reweighting">Fitting the data using a spatially-aware L1 reweighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#finding-unmodeled-jumps">Finding unmodeled jumps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#statistics-of-spatial-reweighting">Statistics of spatial reweighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#model-parameter-correlations">Model parameter correlations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#transient-visualization-with-worm-plots">Transient visualization with worm plots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_3.html#secular-velocity-comparisons">Secular velocity comparisons</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_4.html">Tutorial 4: The use and estimation of covariance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#making-a-noisy-network">Making a noisy network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#fitting-the-models-with-the-spatial-l0-solver">Fitting the models with the spatial L0 solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#quality-of-the-fits">Quality of the fits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#correlation-of-parameters">Correlation of parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#simple-linear-regression-with-restricted-spline-set">Simple linear regression with restricted spline set</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_4.html#empirical-covariance-estimation">Empirical covariance estimation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_5.html">Tutorial 5: Signal Recovery at Low SNR</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_5.html#preparations">Preparations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_5.html#defining-the-variables-and-hyperparameter-space">Defining the variables and hyperparameter space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_5.html#running-test-cases">Running test cases</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_5.html#results">Results</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/tutorial_6.html">Tutorial 6: Spatially-variable Strain Field</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_6.html#preparations">Preparations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_6.html#average-strain-and-rotation">Average strain and rotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/tutorial_6.html#spatially-variable-velocity-strain-and-rotation">Spatially-variable velocity, strain, and rotation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/example_1.html">Example 1: Long Valley Caldera Transient Motions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#preparations">Preparations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#getting-data">Getting data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#building-the-network">Building the network</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#cleaning-the-timeseries">Cleaning the timeseries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#outlier-and-cme-removal">Outlier and CME removal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#first-pass-major-steps-and-noisy-periods">First pass: major steps and noisy periods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/example_1.html#second-pass-minor-catalog-based-steps">Second pass: minor, catalog-based steps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#model-parameter-estimation">Model parameter estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#modeled-horizontal-transient-motion">Modeled horizontal transient motion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#modeled-vertical-seasonal-motion">Modeled vertical seasonal motion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#comparison-of-secular-velocities">Comparison of secular velocities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#final-considerations">Final considerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_1.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/example_2.html">Example 2: Long Valley Caldera Comparisons</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#preparations">Preparations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#homogenous-translation-rotation-and-strain">Homogenous translation, rotation, and strain</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#rotation-about-an-euler-pole">Rotation about an Euler pole</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#comparison-of-different-methods">Comparison of different methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#loading-other-different-datasets">Loading other different datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#north-american-reference-frame">North American reference frame</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#estimate-euler-poles-for-datasets">Estimate Euler poles for datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#map-view-comparison-of-datasets">Map view comparison of datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#quantitative-comparison-of-datasets">Quantitative comparison of datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/example_2.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../faq.html#how-do-i-know-which-penalties-to-use-in-subst">1. How do I know which penalties to use in <code class="xref py py-func docutils literal notranslate"><span class="pre">lasso_regression()</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">ReweightingFunction</span></code>?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../faq.html#how-can-i-save-my-network-object-to-save-time">2. How can I save my <code class="xref py py-class docutils literal notranslate"><span class="pre">Network</span></code> object to save time?</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../disstans.html">DISSTANS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/config.html">Configuration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/config.html#disstans.config.defaults"><code class="docutils literal notranslate"><span class="pre">config.defaults</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/earthquakes.html">Earthquakes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/earthquakes.html#disstans.earthquakes.okada_displacement"><code class="docutils literal notranslate"><span class="pre">okada_displacement()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/earthquakes.html#disstans.earthquakes.okada_prior"><code class="docutils literal notranslate"><span class="pre">okada_prior()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/earthquakes.html#disstans.earthquakes.empirical_prior"><code class="docutils literal notranslate"><span class="pre">empirical_prior()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/models.html">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/models.html#model-parent-class">Model (Parent Class)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#disstans.models.Model"><code class="docutils literal notranslate"><span class="pre">Model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#disstans.models.check_model_dict"><code class="docutils literal notranslate"><span class="pre">check_model_dict()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/models.html#model-collection">Model Collection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#disstans.models.ModelCollection"><code class="docutils literal notranslate"><span class="pre">ModelCollection</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/models.html#fit-collection">Fit Collection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#disstans.models.FitCollection"><code class="docutils literal notranslate"><span class="pre">FitCollection</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/models.html#basic-models">Basic Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#arctangent">Arctangent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#exponential">Exponential</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#hyperbolic-tangent">Hyperbolic Tangent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#logarithmic">Logarithmic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#polynomial">Polynomial</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#step">Step</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#sinusoid">Sinusoid</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/models.html#spline-models">Spline Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#bspline">BSpline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#ispline">ISpline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#basesplineset">BaseSplineSet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#splineset">SplineSet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#decayingsplineset">DecayingSplineSet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/models.html#ampphmodulatedsinusoid">AmpPhModulatedSinusoid</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/network.html">Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network"><code class="docutils literal notranslate"><span class="pre">Network</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__contains__"><code class="docutils literal notranslate"><span class="pre">Network.__contains__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__delitem__"><code class="docutils literal notranslate"><span class="pre">Network.__delitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__getitem__"><code class="docutils literal notranslate"><span class="pre">Network.__getitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__iter__"><code class="docutils literal notranslate"><span class="pre">Network.__iter__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__len__"><code class="docutils literal notranslate"><span class="pre">Network.__len__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__setitem__"><code class="docutils literal notranslate"><span class="pre">Network.__setitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.__str__"><code class="docutils literal notranslate"><span class="pre">Network.__str__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.add_default_local_models"><code class="docutils literal notranslate"><span class="pre">Network.add_default_local_models()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.add_local_models"><code class="docutils literal notranslate"><span class="pre">Network.add_local_models()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.add_station"><code class="docutils literal notranslate"><span class="pre">Network.add_station()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.add_unused_local_models"><code class="docutils literal notranslate"><span class="pre">Network.add_unused_local_models()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.ampphaseplot"><code class="docutils literal notranslate"><span class="pre">Network.ampphaseplot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.analyze_residuals"><code class="docutils literal notranslate"><span class="pre">Network.analyze_residuals()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.call_func_no_return"><code class="docutils literal notranslate"><span class="pre">Network.call_func_no_return()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.call_func_ts_return"><code class="docutils literal notranslate"><span class="pre">Network.call_func_ts_return()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.call_netwide_func"><code class="docutils literal notranslate"><span class="pre">Network.call_netwide_func()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.copy_timeseries"><code class="docutils literal notranslate"><span class="pre">Network.copy_timeseries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.copy_uncertainties"><code class="docutils literal notranslate"><span class="pre">Network.copy_uncertainties()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.create_station"><code class="docutils literal notranslate"><span class="pre">Network.create_station()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.decompose"><code class="docutils literal notranslate"><span class="pre">Network.decompose()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.default_local_models"><code class="docutils literal notranslate"><span class="pre">Network.default_local_models</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.default_location_path"><code class="docutils literal notranslate"><span class="pre">Network.default_location_path</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.euler_rot_field"><code class="docutils literal notranslate"><span class="pre">Network.euler_rot_field()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.evaluate"><code class="docutils literal notranslate"><span class="pre">Network.evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.export_network_ts"><code class="docutils literal notranslate"><span class="pre">Network.export_network_ts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.fit"><code class="docutils literal notranslate"><span class="pre">Network.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.fitevalres"><code class="docutils literal notranslate"><span class="pre">Network.fitevalres()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.freeze"><code class="docutils literal notranslate"><span class="pre">Network.freeze()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.from_json"><code class="docutils literal notranslate"><span class="pre">Network.from_json()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.get_stations_with"><code class="docutils literal notranslate"><span class="pre">Network.get_stations_with()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.get_trend_change"><code class="docutils literal notranslate"><span class="pre">Network.get_trend_change()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.graphical_cme"><code class="docutils literal notranslate"><span class="pre">Network.graphical_cme()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.gui"><code class="docutils literal notranslate"><span class="pre">Network.gui()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.hom_velocity_field"><code class="docutils literal notranslate"><span class="pre">Network.hom_velocity_field()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.import_network_ts"><code class="docutils literal notranslate"><span class="pre">Network.import_network_ts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.load_maintenance_dict"><code class="docutils literal notranslate"><span class="pre">Network.load_maintenance_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.math"><code class="docutils literal notranslate"><span class="pre">Network.math()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.mean_longitude"><code class="docutils literal notranslate"><span class="pre">Network.mean_longitude</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.name"><code class="docutils literal notranslate"><span class="pre">Network.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.num_stations"><code class="docutils literal notranslate"><span class="pre">Network.num_stations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.plot_availability"><code class="docutils literal notranslate"><span class="pre">Network.plot_availability()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.remove_models"><code class="docutils literal notranslate"><span class="pre">Network.remove_models()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.remove_station"><code class="docutils literal notranslate"><span class="pre">Network.remove_station()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.remove_timeseries"><code class="docutils literal notranslate"><span class="pre">Network.remove_timeseries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.spatialfit"><code class="docutils literal notranslate"><span class="pre">Network.spatialfit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.station_locations"><code class="docutils literal notranslate"><span class="pre">Network.station_locations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.station_names"><code class="docutils literal notranslate"><span class="pre">Network.station_names</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.stations"><code class="docutils literal notranslate"><span class="pre">Network.stations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.to_json"><code class="docutils literal notranslate"><span class="pre">Network.to_json()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.unfreeze"><code class="docutils literal notranslate"><span class="pre">Network.unfreeze()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.update_default_local_models"><code class="docutils literal notranslate"><span class="pre">Network.update_default_local_models()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/network.html#disstans.network.Network.wormplot"><code class="docutils literal notranslate"><span class="pre">Network.wormplot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/processing.html">Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/processing.html#unwrap-dict-and-ts">unwrap_dict_and_ts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/processing.html#disstans.processing.unwrap_dict_and_ts"><code class="docutils literal notranslate"><span class="pre">unwrap_dict_and_ts()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/processing.html#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/processing.html#clean">clean</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/processing.html#decompose">decompose</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/processing.html#median">median</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/processing.html#midas">midas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/processing.html#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/processing.html#stepdetector">StepDetector</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/solvers.html">Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/solvers.html#solution-object">Solution Object</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#disstans.solvers.Solution"><code class="docutils literal notranslate"><span class="pre">Solution</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/solvers.html#solver-functions">Solver Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#lasso-regression">lasso_regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#linear-regression">linear_regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#ridge-regression">ridge_regression</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/solvers.html#reweighting-functions">Reweighting Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#reweightingfunction">ReweightingFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#inversereweighting">InverseReweighting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#inversesquaredreweighting">InverseSquaredReweighting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/solvers.html#logarithmicreweighting">LogarithmicReweighting</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/station.html">Station</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station"><code class="docutils literal notranslate"><span class="pre">Station</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.__contains__"><code class="docutils literal notranslate"><span class="pre">Station.__contains__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.__delitem__"><code class="docutils literal notranslate"><span class="pre">Station.__delitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.__getitem__"><code class="docutils literal notranslate"><span class="pre">Station.__getitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.__iter__"><code class="docutils literal notranslate"><span class="pre">Station.__iter__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.__setitem__"><code class="docutils literal notranslate"><span class="pre">Station.__setitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.__str__"><code class="docutils literal notranslate"><span class="pre">Station.__str__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.add_fit"><code class="docutils literal notranslate"><span class="pre">Station.add_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.add_local_model"><code class="docutils literal notranslate"><span class="pre">Station.add_local_model()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.add_local_model_dict"><code class="docutils literal notranslate"><span class="pre">Station.add_local_model_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.add_local_model_kwargs"><code class="docutils literal notranslate"><span class="pre">Station.add_local_model_kwargs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.add_timeseries"><code class="docutils literal notranslate"><span class="pre">Station.add_timeseries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.analyze_residuals"><code class="docutils literal notranslate"><span class="pre">Station.analyze_residuals()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.fits"><code class="docutils literal notranslate"><span class="pre">Station.fits</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.get_arch"><code class="docutils literal notranslate"><span class="pre">Station.get_arch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.get_trend"><code class="docutils literal notranslate"><span class="pre">Station.get_trend()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.get_trend_change"><code class="docutils literal notranslate"><span class="pre">Station.get_trend_change()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.location"><code class="docutils literal notranslate"><span class="pre">Station.location</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.models"><code class="docutils literal notranslate"><span class="pre">Station.models</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.name"><code class="docutils literal notranslate"><span class="pre">Station.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.remove_fit"><code class="docutils literal notranslate"><span class="pre">Station.remove_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.remove_local_models"><code class="docutils literal notranslate"><span class="pre">Station.remove_local_models()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.remove_timeseries"><code class="docutils literal notranslate"><span class="pre">Station.remove_timeseries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.sum_fits"><code class="docutils literal notranslate"><span class="pre">Station.sum_fits()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.timeseries"><code class="docutils literal notranslate"><span class="pre">Station.timeseries</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.ts"><code class="docutils literal notranslate"><span class="pre">Station.ts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/station.html#disstans.station.Station.unused_models"><code class="docutils literal notranslate"><span class="pre">Station.unused_models</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/timeseries.html">Timeseries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/timeseries.html#timeseries-parent-class">Timeseries (Parent Class)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#disstans.timeseries.Timeseries"><code class="docutils literal notranslate"><span class="pre">Timeseries</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/timeseries.html#specialized-classes">Specialized Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#gipsytimeseries">GipsyTimeseries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#gipsyxtimeseries">GipsyXTimeseries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#unrtimeseries">UNRTimeseries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#unrhighratetimeseries">UNRHighRateTimeseries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#f5file">F5File</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/timeseries.html#f5timeseries">F5Timeseries</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../disstans/tools.html">Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/tools.html#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#best-utmzone">best_utmzone</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#block-permutation">block_permutation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#cov2corr">cov2corr</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#create-powerlaw-noise">create_powerlaw_noise</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#date2decyear">date2decyear</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#download-unr-data">download_unr_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#estimate-euler-pole">estimate_euler_pole</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#eulerpole2rotvec">eulerpole2rotvec</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#full-cov-mat-to-columns">full_cov_mat_to_columns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#get-cov-dims">get_cov_dims</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#make-cov-index-map">make_cov_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#get-cov-indices">get_cov_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#get-field-vel-strain-rot">get_field_vel_strain_rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#get-hom-vel-strain-rot">get_hom_vel_strain_rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#parallelize">parallelize</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#parse-maintenance-table">parse_maintenance_table</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#parse-unr-steps">parse_unr_steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#r-ecef2enu">R_ecef2enu</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#r-enu2ecef">R_enu2ecef</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#rotvec2eulerpole">rotvec2eulerpole</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#selectpair">selectpair</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#strain-rotation-invariants">strain_rotation_invariants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#tvec-to-numpycol">tvec_to_numpycol</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#weighted-median">weighted_median</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../disstans/tools.html#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#click">Click</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#rinexdataholding">RINEXDataHolding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../disstans/tools.html#timedelta">Timedelta</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DISSTANS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">disstans.processing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for disstans.processing</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains some processing functions that while not belonging</span>
<span class="sd">to a specific class, require them to already be loaded and DISSTANS to</span>
<span class="sd">be initialized.</span>

<span class="sd">For general helper functions, see :mod:`~disstans.tools`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial.polynomial</span> <span class="kn">import</span> <span class="n">Polynomial</span> <span class="k">as</span> <span class="n">NpPolynomial</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span><span class="p">,</span> <span class="n">FastICA</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">pandas.api.indexers</span> <span class="kn">import</span> <span class="n">BaseIndexer</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Literal</span>

<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">defaults</span>
<span class="kn">from</span> <span class="nn">.timeseries</span> <span class="kn">import</span> <span class="n">Timeseries</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">Timedelta</span><span class="p">,</span> <span class="n">parallelize</span><span class="p">,</span> <span class="n">tvec_to_numpycol</span><span class="p">,</span> <span class="n">date2decyear</span><span class="p">,</span> <span class="n">selectpair</span>
<span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">Polynomial</span>
<span class="kn">from</span> <span class="nn">.station</span> <span class="kn">import</span> <span class="n">Station</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.network</span> <span class="kn">import</span> <span class="n">Network</span>


<div class="viewcode-block" id="unwrap_dict_and_ts">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.unwrap_dict_and_ts">[docs]</a>
<span class="k">def</span> <span class="nf">unwrap_dict_and_ts</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper decorator that aims at simplifying the coding of processing functions.</span>
<span class="sd">    Ideally, a new function that doesn&#39;t need to know if its input is a</span>
<span class="sd">    :class:`~disstans.timeseries.Timeseries`, :class:`~pandas.DataFrame`,</span>
<span class="sd">    :class:`~numpy.ndarray` or a dictionary containing them, should not need to reimplement</span>
<span class="sd">    a check and conversion for all of these because they just represent a data</span>
<span class="sd">    array of some form. So, by providing this function decorator, a wrapped function</span>
<span class="sd">    only needs to be able to work for a single array (plus some optional keyword arguments).</span>
<span class="sd">    The wrapping will extract the data of the input types and convert the returned</span>
<span class="sd">    array from ``func`` into the original format.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    A basic function of the form::</span>

<span class="sd">        def func(in_array, **kw_args):</span>
<span class="sd">            # do some things</span>
<span class="sd">            return out_array</span>

<span class="sd">    that takes and returns a NumPy array can be wrapped as follows</span>
<span class="sd">    to be able to also take and return all the other data forms::</span>

<span class="sd">        @unwrap_dict_and_ts</span>
<span class="sd">        def func(in_array, **kw_args):</span>
<span class="sd">            # do some things</span>
<span class="sd">            return out_array</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func</span>
<span class="sd">        Function to be wrapped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ts&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
            <span class="n">was_dict</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">was_dict</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">additional_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># loop over components</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">Timeseries</span><span class="p">):</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot unwrap object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">func_output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">additional_output</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_output</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">additional_output</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func_output</span>
                <span class="n">additional_output</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># save results</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">Timeseries</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">only_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">out</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">elem</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">additional_output</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">has_additional_output</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_additional_output</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_dict</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span>
            <span class="n">additional_output</span> <span class="o">=</span> <span class="n">additional_output</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">has_additional_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">additional_output</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>



<span class="k">class</span> <span class="nc">ExpandingRollingIndexer</span><span class="p">(</span><span class="n">BaseIndexer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Indexer class used in the pandas rolling calculations (e.g., rolling median).</span>
<span class="sd">    This custom indexer behaves like a regular rolling window, except at the</span>
<span class="sd">    start and end of the timeseries, where the window slowly grows or shrinks,</span>
<span class="sd">    respectively. Specifically, at the first time step, the window is only one</span>
<span class="sd">    element wide. At the second step, it is three elements wide; at the third,</span>
<span class="sd">    five elements, and so forth, until the window has the defined window size.</span>
<span class="sd">    As the window approaches the end of the timeseries, it starts to shrink again</span>
<span class="sd">    until it is one element wide at the last time step.</span>

<span class="sd">    The goal of this kind of rolling window is to reduce the influence of late</span>
<span class="sd">    (early) observations when looking at the first (last) timesteps (respectively).</span>

<span class="sd">    For more information, see the pandas documentation about `custom window rolling</span>
<span class="sd">    &lt;https://pandas.pydata.org/docs/user_guide/window.html#custom-window-rolling&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_window_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">num_values</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                          <span class="n">min_periods</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                          <span class="n">center</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                          <span class="n">closed</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                          <span class="n">step</span><span class="p">:</span> <span class="n">Any</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the function that needs to be implemented for the</span>
<span class="sd">        :class:`~pandas.api.indexers.BaseIndexer` class to be used for all</span>
<span class="sd">        rolling pandas operations. It shouldn&#39;t be called manually.</span>

<span class="sd">        The parameters ``min_periods``, ``center``, ``closed``, and ``step`` have to</span>
<span class="sd">        be included to match expected pandas behavior, but this function</span>
<span class="sd">        does not implement their potential features.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_values</span>
<span class="sd">            Total number of values in the array to be rolled through.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start</span>
<span class="sd">            Start indices of individual windows.</span>
<span class="sd">        end</span>
<span class="sd">            End indices (exclusive) of individual windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># window_size is set by BaseIndexer.__init__</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;&#39;window_size&#39; must be odd, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span>
        <span class="c1"># initialize index arrays</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="c1"># left and right boundaries for the boundary intervals</span>
        <span class="n">max_ix_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">max_ix_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># starting interval</span>
        <span class="n">start</span><span class="p">[:</span><span class="n">max_ix_start</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_ix_start</span><span class="p">)</span>
        <span class="n">end</span><span class="p">[:</span><span class="n">max_ix_start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_ix_start</span><span class="p">)</span>
        <span class="c1"># ending interval</span>
        <span class="n">start</span><span class="p">[</span><span class="o">-</span><span class="n">max_ix_end</span><span class="p">:]</span> <span class="o">=</span> <span class="n">num_values</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_ix_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end</span><span class="p">[</span><span class="o">-</span><span class="n">max_ix_end</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">max_ix_end</span><span class="p">)</span>
        <span class="c1"># middle, regular interval</span>
        <span class="n">start</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_values</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>
        <span class="c1"># return</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span>


<div class="viewcode-block" id="median">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.median">[docs]</a>
<span class="nd">@unwrap_dict_and_ts</span>
<span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the rolling median filter column-wise. Missing observations (NaNs) are</span>
<span class="sd">    ignored during the median calculation, but missing observations are not imputed</span>
<span class="sd">    from the rolling median (i.e., a NaN value remains a NaN value, but does not</span>
<span class="sd">    affect surrounding values).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array</span>
<span class="sd">        2D input array (can contain NaNs).</span>
<span class="sd">        Wrapped by :func:`~disstans.processing.unwrap_dict_and_ts` to also accept</span>
<span class="sd">        :class:`~disstans.timeseries.Timeseries`, :class:`~pandas.DataFrame` and</span>
<span class="sd">        dictionaries of them as input.</span>
<span class="sd">    kernel_size</span>
<span class="sd">        Kernel size (length of moving window to compute the median over).</span>
<span class="sd">        Has to be an odd number.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        2D filtered array (may still contain NaNs).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure the array is 2D even if it&#39;s only a single column</span>
    <span class="n">num_obs</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_obs</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># the indexer object will tell pandas over which windows to calculate the median</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="n">ExpandingRollingIndexer</span><span class="p">(</span><span class="n">window_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="c1"># now we calculate the rolling median (this is compiled-optimized by pandas)</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># add NaNs again to where they were initially</span>
    <span class="n">filtered</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">filtered</span></div>



<div class="viewcode-block" id="decompose">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.decompose">[docs]</a>
<span class="nd">@unwrap_dict_and_ts</span>
<span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
              <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pca&quot;</span><span class="p">,</span> <span class="s2">&quot;ica&quot;</span><span class="p">],</span>
              <span class="n">num_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
              <span class="n">return_sources</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">detrend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">impute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">rng</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decomposes the input signal into different components using PCA or ICA.</span>
<span class="sd">    Optionally detrends the data and/or fills missing data using the data</span>
<span class="sd">    decomposition model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array</span>
<span class="sd">        Input array of shape :math:`(\text{num_observations},\text{n_stations})`</span>
<span class="sd">        (can contain NaNs).</span>
<span class="sd">        Wrapped by :func:`~disstans.processing.unwrap_dict_and_ts` to also accept</span>
<span class="sd">        :class:`~disstans.timeseries.Timeseries`, :class:`~pandas.DataFrame` and</span>
<span class="sd">        dictionaries of them as input (i.e. the output of</span>
<span class="sd">        :meth:`~disstans.network.Network.export_network_ts`).</span>
<span class="sd">    method</span>
<span class="sd">        Method to use to decompose the array. Possible values are ``&#39;pca&#39;`` and ``&#39;ica&#39;``:</span>
<span class="sd">        ``&#39;pca&#39;`` uses :class:`~sklearn.decomposition.PCA` (motivated by [dong06]_), whereas</span>
<span class="sd">        ``&#39;ica&#39;`` uses :class:`~sklearn.decomposition.FastICA` (motivated by [huang12]_).</span>
<span class="sd">    num_components</span>
<span class="sd">        Number of components to estimate. If ``None``, all are used.</span>
<span class="sd">    return_sources</span>
<span class="sd">        If ``True``, return not only the best-fit model, but also the sources</span>
<span class="sd">        themselves in space and time. Defaults to ``False``.</span>
<span class="sd">    detrend</span>
<span class="sd">        If ``True``, detrend the data before decomposing it assuming uniform data</span>
<span class="sd">        sampling. Alternatively, a 1D array containing the data indices for detrending.</span>
<span class="sd">    impute</span>
<span class="sd">        If ``False``, the input data is overwritten with the fitted model, and missing</span>
<span class="sd">        data is kept missing.</span>
<span class="sd">        If ``True``, input data is kept and the fitted data decomposition model is</span>
<span class="sd">        only used to fill the missing values.</span>
<span class="sd">    rng</span>
<span class="sd">        Random number generator instance to use to fill missing values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    model</span>
<span class="sd">        Best-fit model with shape :math:`(\text{num_observations},\text{n_stations})`.</span>
<span class="sd">    temporal</span>
<span class="sd">        Only if ``return_sources=True``: Temporal source with shape</span>
<span class="sd">        :math:`(\text{num_observations},\text{num_components})`.</span>
<span class="sd">    spatial</span>
<span class="sd">        Only if ``return_sources=True``: Spatial source with shape</span>
<span class="sd">        :math:`(\text{num_components},\text{n_stations})`.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [dong06] Dong, D., Fang, P., Bock, Y., Webb, F., Prawirodirdjo, L.,</span>
<span class="sd">       Kedar, S., &amp; Jamason, P. (2006). *Spatiotemporal filtering using principal component</span>
<span class="sd">       analysis and Karhunen-Loeve expansion approaches for regional GPS network analysis*.</span>
<span class="sd">       Journal of Geophysical Research: Solid Earth, 111(B3).</span>
<span class="sd">       doi:`10.1029/2005JB003806 &lt;https://doi.org/10.1029/2005JB003806&gt;`_.</span>
<span class="sd">    .. [huang12] Huang, D. W., Dai, W. J., &amp; Luo, F. X. (2012).</span>
<span class="sd">       *ICA Spatiotemporal Filtering Method and Its Application in GPS Deformation Monitoring*.</span>
<span class="sd">       Applied Mechanics and Materials, 204–208, 2806–2812.</span>
<span class="sd">       doi:`10.4028/www.scientific.net/AMM.204-208.2806</span>
<span class="sd">       &lt;http://dx.doi.org/10.4028/www.scientific.net/AMM.204-208.2806&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ignore all only-NaN columns</span>
    <span class="n">array_nanind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">finite_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">array_nanind</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nan_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">array_nanind</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">finite_cols</span><span class="p">]</span>
    <span class="n">array_nanind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="c1"># save values for later reinsertion if imputing data</span>
    <span class="k">if</span> <span class="n">impute</span><span class="p">:</span>
        <span class="n">array_in</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># detrend if desired</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">detrend</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">detrend</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">detrend</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">detrend</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">detrend</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">detrend</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> \
                <span class="sa">f</span><span class="s2">&quot;&#39;detrend&#39; array needs to be 1D with length </span><span class="si">{</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, got &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;shape </span><span class="si">{</span><span class="n">detrend</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> instead.&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">detrend</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">fits</span> <span class="o">=</span> <span class="p">[</span><span class="n">NpPolynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">array_nanind</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]],</span>
                                 <span class="n">array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">][</span><span class="o">~</span><span class="n">array_nanind</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">array_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fits</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">-=</span> <span class="n">array_trend</span>
        <span class="n">detrended</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">detrend</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized &#39;detrend&#39; argument type: &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">detrend</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">detrended</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># fill NaNs with white Gaussian noise</span>
    <span class="n">array_nanmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">array_nansd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">),</span> <span class="s2">&quot;&#39;rng&#39; needs to be None or a &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;Generator instance, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">array</span><span class="p">[</span><span class="n">array_nanind</span><span class="p">[:,</span> <span class="n">icol</span><span class="p">],</span> <span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_nanmean</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span> <span class="o">+</span> \
            <span class="n">array_nansd</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">array_nanind</span><span class="p">[:,</span> <span class="n">icol</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="c1"># decompose using the specified solver</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;pca&#39;</span><span class="p">:</span>
        <span class="n">decomposer</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">num_components</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ica&#39;</span><span class="p">:</span>
        <span class="n">decomposer</span> <span class="o">=</span> <span class="n">FastICA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">num_components</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="s2">&quot;unit-variance&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot estimate the common mode error &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;using the &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; method.&quot;</span><span class="p">)</span>
    <span class="c1"># extract temporal component and build model</span>
    <span class="n">temporal</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">temporal</span><span class="p">)</span>
    <span class="c1"># add trends back in if they were removed</span>
    <span class="k">if</span> <span class="n">detrended</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">+=</span> <span class="n">array_trend</span>
    <span class="c1"># restore original data</span>
    <span class="k">if</span> <span class="n">impute</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">model</span><span class="p">[</span><span class="o">~</span><span class="n">array_nanind</span><span class="p">[:,</span> <span class="n">icol</span><span class="p">],</span> <span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_in</span><span class="p">[</span><span class="o">~</span><span class="n">array_nanind</span><span class="p">[:,</span> <span class="n">icol</span><span class="p">],</span> <span class="n">icol</span><span class="p">]</span>
    <span class="c1"># reduce to where original timeseries were not NaNs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model</span><span class="p">[</span><span class="n">array_nanind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">nan_cols</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">newmod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">temporal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">finite_cols</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nan_cols</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">newmod</span><span class="p">[:,</span> <span class="n">finite_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">newmod</span>
    <span class="c1"># extract spatial component if to be returned, else done</span>
    <span class="k">if</span> <span class="n">return_sources</span><span class="p">:</span>
        <span class="n">spatial</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">components_</span>
        <span class="k">if</span> <span class="n">nan_cols</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newspat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">spatial</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">finite_cols</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nan_cols</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">newspat</span><span class="p">[:,</span> <span class="n">finite_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">spatial</span>
            <span class="n">spatial</span> <span class="o">=</span> <span class="n">newspat</span>
        <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">temporal</span><span class="p">,</span> <span class="n">spatial</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model</span></div>



<div class="viewcode-block" id="clean">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.clean">[docs]</a>
<span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="n">station</span><span class="p">:</span> <span class="n">Station</span><span class="p">,</span>
          <span class="n">ts_in</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
          <span class="n">reference</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Timeseries</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">,</span>
          <span class="n">ts_out</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">clean_kw_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
          <span class="n">reference_callable_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function operating on a single station&#39;s timeseries to clean it from outliers,</span>
<span class="sd">    and mask it out if the data is not good enough. The criteria are set by</span>
<span class="sd">    :attr:`~disstans.config.defaults` but can be overriden by providing ``clean_kw_args``.</span>
<span class="sd">    The criteria are:</span>

<span class="sd">    - ``&#39;min_obs&#39;``: Minimum number of observations the timeseries has to contain.</span>
<span class="sd">    - ``&#39;std_outlier&#39;``: Classify as an outlier any observation that is this many</span>
<span class="sd">      standard deviations away from the reference.</span>
<span class="sd">    - ``&#39;std_bad&#39;``: Classify as an outlier any observation that has an absolute standard</span>
<span class="sd">      deviation larger than this.</span>
<span class="sd">    - ``&#39;iqr_outlier&#39;``: Classify as an outlier any observation that is this many</span>
<span class="sd">      inter-quartile ranges (IQR, difference between the 25th and 75th percentile)</span>
<span class="sd">      away from the reference&#39;s 25th-75th percentile range.</span>
<span class="sd">    - ``&#39;std_thresh&#39;``: After the removal of outliers, the maximum standard deviation</span>
<span class="sd">      that the residual between reference and input timeseries is allowed to have.</span>
<span class="sd">    - ``&#39;min_clean_obs&#39;``: After the removal of outliers, the minimum number of</span>
<span class="sd">      observations the timeseries has to contain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    station</span>
<span class="sd">        Station to operate on.</span>
<span class="sd">    ts_in</span>
<span class="sd">        Description of the timeseries to clean.</span>
<span class="sd">    reference</span>
<span class="sd">        Reference timeseries.</span>
<span class="sd">        If string, checks for a timeseries with that description in the ``station``.</span>
<span class="sd">        If a :class:`~disstans.timeseries.Timeseries` instance, use it directly.</span>
<span class="sd">        If a function, the reference timeseries will be calculated as</span>
<span class="sd">        ``t_ref = reference(ts_in, **reference_callable_args)``.</span>
<span class="sd">    ts_out</span>
<span class="sd">        If provided, duplicate ``ts_in`` to a new timeseries ``ts_out``</span>
<span class="sd">        and clean the copy (to preserve the raw timeseries).</span>
<span class="sd">    clean_kw_args</span>
<span class="sd">        Override the default cleaning criteria in :attr:`~disstans.config.defaults`,</span>
<span class="sd">        see the explanations above.</span>
<span class="sd">    reference_callable_args</span>
<span class="sd">        If ``reference`` is a function, ``reference_callable_args`` can be used</span>
<span class="sd">        to pass additional keyword arguments to the former when calculating</span>
<span class="sd">        the reference timeseries.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    By default, this function operates *in-place*. If you don&#39;t wish to overwrite</span>
<span class="sd">    the raw input timeseries, specify ``ts_out``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clean_settings</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;clean&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">clean_settings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">clean_kw_args</span><span class="p">)</span>
    <span class="c1"># check if timeseries is present</span>
    <span class="k">if</span> <span class="n">ts_in</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">station</span><span class="o">.</span><span class="n">timeseries</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find timeseries &#39;</span><span class="si">{</span><span class="n">ts_in</span><span class="si">}</span><span class="s2">&#39; in station </span><span class="si">{</span><span class="n">station</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
             <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># check if we&#39;re modifying in-place or copying</span>
    <span class="k">if</span> <span class="n">ts_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="n">ts_in</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="n">ts_in</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">only_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s1">&#39;clean&#39;</span><span class="p">)</span>
    <span class="c1"># check if we have a reference time series or need to calculate one</span>
    <span class="c1"># in the latter case, the input is name of function to call</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Timeseries</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">reference</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;reference&#39; has to either be a Timeseries, the name of one, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;or a function, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Timeseries</span><span class="p">):</span>
        <span class="n">ts_ref</span> <span class="o">=</span> <span class="n">reference</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># get reference time series</span>
        <span class="n">ts_ref</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="n">reference</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">reference</span><span class="p">):</span>
        <span class="n">ts_ref</span> <span class="o">=</span> <span class="n">reference</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">reference_callable_args</span><span class="p">)</span>
    <span class="c1"># check that both timeseries have the same data columns</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ts_ref</span><span class="o">.</span><span class="n">data_cols</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">data_cols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reference time series has to have the same data columns as &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;input time series, but got </span><span class="si">{</span><span class="n">ts_ref</span><span class="o">.</span><span class="n">data_cols</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">data_cols</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># find variance columns if necessary</span>
    <span class="k">if</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_bad&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">station</span><span class="p">[</span><span class="n">ts_in</span><span class="p">]</span><span class="o">.</span><span class="n">var_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_bad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d2v</span> <span class="o">=</span> <span class="p">{</span><span class="n">station</span><span class="p">[</span><span class="n">ts_in</span><span class="p">]</span><span class="o">.</span><span class="n">data_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">station</span><span class="p">[</span><span class="n">ts_in</span><span class="p">]</span><span class="o">.</span><span class="n">var_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">num_components</span><span class="p">)}</span>
            <span class="n">check_bad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># iterate cleaning over all data components</span>
    <span class="k">for</span> <span class="n">dcol</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">data_cols</span><span class="p">:</span>
        <span class="c1"># check for minimum number of observations</span>
        <span class="k">if</span> <span class="n">ts</span><span class="p">[</span><span class="n">dcol</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;min_obs&quot;</span><span class="p">]:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">mask_out</span><span class="p">(</span><span class="n">dcol</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="c1"># remove outliers by absolute uncertainty</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_bad&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">check_bad</span><span class="p">:</span>
            <span class="n">mask_bad</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="n">ts_in</span><span class="p">][</span><span class="n">d2v</span><span class="p">[</span><span class="n">dcol</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_bad&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_bad</span><span class="p">,</span> <span class="n">dcol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># compute residuals</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_outlier&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;iqr_outlier&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_thresh&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">dcol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">ts_ref</span><span class="p">[</span><span class="n">dcol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span>
        <span class="c1"># check for and remove outliers</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_outlier&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;iqr_outlier&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span>
            <span class="n">mask_copy</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_outlier&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">mask_copy</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="n">mask_copy</span><span class="p">])</span>
                                    <span class="o">&gt;</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_outlier&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;iqr_outlier&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
                <span class="n">q3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span>
                <span class="n">iqr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">mask_copy</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="n">mask_copy</span><span class="p">]</span>
                                                 <span class="o">&lt;</span> <span class="n">q1</span> <span class="o">-</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;iqr_outlier&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">iqr</span><span class="p">,</span>
                                                 <span class="n">residual</span><span class="p">[</span><span class="n">mask_copy</span><span class="p">]</span>
                                                 <span class="o">&gt;</span> <span class="n">q3</span> <span class="o">+</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;iqr_outlier&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">iqr</span><span class="p">)</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">dcol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">dcol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">ts_ref</span><span class="p">[</span><span class="n">dcol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span>
        <span class="c1"># check for minimum number of clean observations</span>
        <span class="k">if</span> <span class="n">ts</span><span class="p">[</span><span class="n">dcol</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;min_clean_obs&quot;</span><span class="p">]:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">mask_out</span><span class="p">(</span><span class="n">dcol</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="c1"># check if total standard deviation is still too large</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_thresh&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sd</span> <span class="o">&gt;</span> <span class="n">clean_settings</span><span class="p">[</span><span class="s2">&quot;std_thresh&quot;</span><span class="p">]):</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">mask_out</span><span class="p">(</span><span class="n">dcol</span><span class="p">)</span>
    <span class="c1"># if we made a copy, add it to the station, otherwise we&#39;re already done</span>
    <span class="k">if</span> <span class="n">ts_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">station</span><span class="o">.</span><span class="n">add_timeseries</span><span class="p">(</span><span class="n">ts_out</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span></div>



<div class="viewcode-block" id="midas">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.midas">[docs]</a>
<span class="k">def</span> <span class="nf">midas</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">Timeseries</span><span class="p">,</span>
          <span class="n">steps</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span>
          <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Polynomial</span><span class="p">,</span> <span class="n">Timeseries</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs the MIDAS estimate as described by [blewitt16]_.</span>
<span class="sd">    It is adapted from the Fortran code provided by the author (see</span>
<span class="sd">    :func:`~disstans.tools.selectpair` for more details and original copyright).</span>

<span class="sd">    MIDAS returns the median estimate of secular (constant) velocities in all data</span>
<span class="sd">    components using data pairs spanning exactly one year. By not including pairs</span>
<span class="sd">    crossing known step epochs and using a fixed period, the influence of unmodeled</span>
<span class="sd">    jumps and seasonal variations can be minimized. At the end, an empirical estimate</span>
<span class="sd">    of the velocities&#39; uncertainty is calculated as well.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts</span>
<span class="sd">        Timeseries to perform the MIDAS algorithm on.</span>
<span class="sd">    steps</span>
<span class="sd">        If given, a pandas Series or Index of step times, across which no pairs</span>
<span class="sd">        should be formed.</span>
<span class="sd">    tolerance</span>
<span class="sd">        Tolerance when enforcing the one-year period of pairs (in 365.25-days-long years`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mdl</span>
<span class="sd">        Fitted polynomial (offset &amp; constant velocity) model.</span>
<span class="sd">    res</span>
<span class="sd">        Residual timeseries.</span>
<span class="sd">    stats</span>
<span class="sd">        Fittings statistics computed along the way.</span>
<span class="sd">        ``&#39;num_epochs&#39;``, ``&#39;num_used&#39;``, ``&#39;num_pairs&#39;``, and ``&#39;nstep&#39;`` are the number of</span>
<span class="sd">        epochs in ``ts``, the number of epochs used in the velocity pairs, the number of pairs</span>
<span class="sd">        formed, and the number of included steps, respectively. ``&#39;frac_removed&#39;`` and</span>
<span class="sd">        ``&#39;sd_velpairs&#39;`` are the fraction of removed pairs (because of velocity pairs more</span>
<span class="sd">        than two standard deviations away from their medians) and the estimated standard</span>
<span class="sd">        deviation of the velocity pairs, respectively, and for each component.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [blewitt16] Blewitt, G., Kreemer, C., Hammond, W. C., &amp; Gazeaux, J. (2016).</span>
<span class="sd">       *MIDAS robust trend estimator for accurate GPS station velocities without step detection.*</span>
<span class="sd">       Journal of Geophysical Research: Solid Earth, 121(3), 2054–2068.</span>
<span class="sd">       doi:`10.1002/2015JB012552 &lt;https://doi.org/10.1002/2015JB012552&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># extract timeseries data, adjust zero-crossing to first epoch</span>
    <span class="n">x_off</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">x_off</span>
    <span class="c1"># convert timeseries index and step times to decimal years</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">date2decyear</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
    <span class="n">tstep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># need at least one entry for selectpair</span>
    <span class="k">if</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tstep_back</span> <span class="o">=</span> <span class="n">tstep</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">steps_decyear</span> <span class="o">=</span> <span class="n">date2decyear</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="n">tstep_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="o">-</span><span class="n">steps_decyear</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tstep</span><span class="p">])</span>
        <span class="n">tstep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">steps_decyear</span><span class="p">,</span> <span class="n">tstep</span><span class="p">])</span>
    <span class="c1"># get forward and backwards time pairs</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">selectpair</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tstep</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
    <span class="n">num_pairs</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ipb</span> <span class="o">=</span> <span class="n">selectpair</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tstep_back</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="n">ipb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num_pairs</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only found </span><span class="si">{</span><span class="n">num_pairs</span><span class="si">}</span><span class="s2"> forward and </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2"> backward pairs; solution will be bad.&quot;</span><span class="p">,</span>
             <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># convert backward indices to forward ones</span>
    <span class="n">ipb</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">ipb</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
    <span class="c1"># combine the two index collections, and make them more readable</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ip</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ipb</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ip_from</span><span class="p">,</span> <span class="n">ip_to</span> <span class="o">=</span> <span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">num_pairs</span> <span class="o">+=</span> <span class="n">nb</span>
    <span class="c1"># calculate number of points used in pairing</span>
    <span class="n">num_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
    <span class="c1"># compute velocity for all pairs</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ip_to</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ip_from</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">ip_to</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">ip_from</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># median of the velocities</span>
    <span class="n">v50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># absolute deviation from the median</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">v50</span><span class="p">)</span>
    <span class="c1"># median absolute deviation (MAD)</span>
    <span class="n">d50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># estimated standard deviation of velocities</span>
    <span class="c1"># (based on theoretical factor 1.4826)</span>
    <span class="n">sd_velpairs</span> <span class="o">=</span> <span class="mf">1.4826</span> <span class="o">*</span> <span class="n">d50</span>
    <span class="c1"># delete velocities more than 2 s.d. from MAD</span>
    <span class="n">v</span><span class="p">[</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sd_velpairs</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">num_kept</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># recompute median, absolute deviation, MAD, and estimated s.d.</span>
    <span class="n">v50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">v50</span><span class="p">)</span>
    <span class="n">d50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sd_velpairs</span> <span class="o">=</span> <span class="mf">1.4826</span> <span class="o">*</span> <span class="n">d50</span>
    <span class="c1"># Standard errors for the median velocity</span>
    <span class="c1"># Multiply by theoretical factor of sqrt(pi/2) = 1.2533</span>
    <span class="c1"># Divide number of data by 4 since we use coordinate data a nominal 4 times</span>
    <span class="c1"># Also scale standard errors by ad hoc factor of 3 to be realistic</span>
    <span class="n">sv</span> <span class="o">=</span> <span class="mf">1.2533</span> <span class="o">*</span> <span class="n">sd_velpairs</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_kept</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="c1"># compute intercepts</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">v50</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">x50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># compute residuals</span>
    <span class="n">r</span> <span class="o">-=</span> <span class="n">x50</span>
    <span class="c1"># fraction of pairs removed</span>
    <span class="n">frac_removed</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_pairs</span> <span class="o">-</span> <span class="n">num_kept</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_pairs</span>
    <span class="c1"># return offet &amp; velocity as linear Polynomial model</span>
    <span class="c1"># intercept uncertainty is &quot;perfect&quot; since it wasn&#39;t estimated at all,</span>
    <span class="c1"># it&#39;s just relative to a reference time</span>
    <span class="n">mdl</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_reference</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_unit</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>
    <span class="n">mdl</span><span class="o">.</span><span class="n">read_parameters</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x50</span> <span class="o">+</span> <span class="n">x_off</span><span class="p">,</span> <span class="n">v50</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">covariances</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x50</span><span class="p">),</span> <span class="n">sv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="c1"># return residual as a Timeseries</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Timeseries</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">timevector</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s2">&quot;midas&quot;</span><span class="p">,</span>
                                <span class="n">data_unit</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">data_unit</span><span class="p">,</span>
                                <span class="n">data_cols</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dcol</span><span class="si">}</span><span class="s2">_midasres&quot;</span> <span class="k">for</span> <span class="n">dcol</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">data_cols</span><span class="p">])</span>
    <span class="c1"># all other stats are returned in a dictionary</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;num_epochs&quot;</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s2">&quot;num_used&quot;</span><span class="p">:</span> <span class="n">num_used</span><span class="p">,</span> <span class="s2">&quot;num_pairs&quot;</span><span class="p">:</span> <span class="n">num_pairs</span><span class="p">,</span>
             <span class="s2">&quot;frac_removed&quot;</span><span class="p">:</span> <span class="n">frac_removed</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="s2">&quot;sd_velpairs&quot;</span><span class="p">:</span> <span class="n">sd_velpairs</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
             <span class="s2">&quot;nstep&quot;</span><span class="p">:</span> <span class="n">tstep</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
    <span class="c1"># return</span>
    <span class="k">return</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">stats</span></div>



<div class="viewcode-block" id="StepDetector">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector">[docs]</a>
<span class="k">class</span> <span class="nc">StepDetector</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements a step detector based on the Akaike Information Criterion (AIC).</span>

<span class="sd">    A window is moved over the input data, and two linear models are fit in the</span>
<span class="sd">    method :meth:`~search`: one containing only a linear polynomial, and one containing an</span>
<span class="sd">    additional step in the middle of the window. Then, using the AIC, the relative</span>
<span class="sd">    probabilities are calculated, and saved for each timestep.</span>

<span class="sd">    In the final step, one can threshold these relative probabilities with the method</span>
<span class="sd">    :meth:`~steps`, and look for local maxima, which will correspond to probable steps.</span>

<span class="sd">    If the class is constructed with ``kernel_size``, ``x`` and ``y`` passed, it automatically</span>
<span class="sd">    calls its method :meth:`~search`, otherwise, :meth:`~search` needs to be called manually.</span>
<span class="sd">    Running the method again with a different ``kernel_size``, ``x`` or ``y`` will overwrite</span>
<span class="sd">    previous results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kernel_size</span>
<span class="sd">        Window size of the detector. Must be odd.</span>
<span class="sd">    kernel_size_min</span>
<span class="sd">        Minimum window size of the detector (for edges). Must be smaller than or equal</span>
<span class="sd">        to ``kernel_size``.</span>
<span class="sd">    x</span>
<span class="sd">        Input array of shape :math:`(\text{num_observations},)`.</span>
<span class="sd">        Should not contain NaNs.</span>
<span class="sd">    y</span>
<span class="sd">        Input array of shape :math:`(\text{num_observations}, \text{num_components})`.</span>
<span class="sd">        Can contain NaNs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">kernel_size_min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span> <span class="o">=</span> <span class="n">kernel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size_min</span> <span class="o">=</span> <span class="n">kernel_size_min</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kernel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Kernel (window) size of the detector. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;kernel_size&#39; has not yet been set.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span>

    <span class="nd">@kernel_size</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">kernel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kernel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kernel_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> \
                <span class="sa">f</span><span class="s2">&quot;&#39;kernel_size&#39; must be an odd integer or None, got </span><span class="si">{</span><span class="n">kernel_size</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span> <span class="o">=</span> <span class="n">kernel_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_size_min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Minimum kernel (window) size of the detector. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;kernel_size_min&#39; has not yet been set.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size_min</span>

    <span class="nd">@kernel_size_min</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">kernel_size_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel_size_min</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kernel_size_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">kernel_size_min</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">,</span> <span class="s2">&quot;&#39;kernel_size_min&#39; must be smaller &quot;</span> <span class="o">+</span> \
                <span class="sa">f</span><span class="s2">&quot;or equal to &#39;kernel_size&#39;, but </span><span class="si">{</span><span class="n">kernel_size_min</span><span class="si">}</span><span class="s2"> &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size_min</span> <span class="o">=</span> <span class="n">kernel_size_min</span>

<div class="viewcode-block" id="StepDetector.AIC_c">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector.AIC_c">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">AIC_c</span><span class="p">(</span><span class="n">rss</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Akaike Information Criterion for small samples for Least Squares</span>
<span class="sd">        regression results. Implementation is based on [burnhamanderson02]_ (ch. 2).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rss</span>
<span class="sd">            Residual sum of squares.</span>
<span class="sd">        n</span>
<span class="sd">            Number of samples.</span>
<span class="sd">        K</span>
<span class="sd">            Degrees of freedom. If the Least Squares model has :math:`\text{num_parameters}`</span>
<span class="sd">            parameters (including the mean), then the degrees of freedom are</span>
<span class="sd">            :math:`K = \text{num_parameters} + 1`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The Small Sample AIC for Least Squares :math:`\text{AIC}_c`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>

<span class="sd">        .. [burnhamanderson02] (2002) *Information and Likelihood Theory:</span>
<span class="sd">           A Basis for Model Selection and Inference.* In: Burnham K.P., Anderson D.R. (eds)</span>
<span class="sd">           Model Selection and Multimodel Inference. Springer, New York, NY.</span>
<span class="sd">           doi:`10.1007/978-0-387-22456-5_2 &lt;https://doi.org/10.1007/978-0-387-22456-5_2&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input check</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">-</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># can&#39;t return meaningful statistic, hypothesis unlikely</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># calculate AIC for LS</span>
        <span class="n">AIC</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rss</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">K</span>
        <span class="c1"># apply small sample size correction</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AIC</span> <span class="o">+</span> <span class="n">correction</span></div>


<div class="viewcode-block" id="StepDetector.test_single">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector.test_single">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">test_single</span><span class="p">(</span><span class="n">xwindow</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">ywindow</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">valid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">maxdel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single window (of arbitrary, but odd length), perform the AIC hypothesis test</span>
<span class="sd">        whether a step is likely present (H1) or not (H0) in the ``y`` data given</span>
<span class="sd">        ``x`` coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xwindow</span>
<span class="sd">            Time array of shape :math:`(\text{num_window},)`.</span>
<span class="sd">            Should not contain NaNs.</span>
<span class="sd">        ywindow</span>
<span class="sd">            Data array of shape :math:`(\text{num_window},)`.</span>
<span class="sd">            Should not contain NaNs.</span>
<span class="sd">        valid</span>
<span class="sd">            Mask array of the data of shape :math:`(\text{num_window},)`,</span>
<span class="sd">            with ``1`` where the ``ywindow`` is finite (not NaN or infinity).</span>
<span class="sd">            If not passed to the function, it is calculated internally, which will slow</span>
<span class="sd">            down the computation.</span>
<span class="sd">        maxdel</span>
<span class="sd">            Difference in AIC that should be considered not significantly better.</span>
<span class="sd">            (Refers to :math:`\Delta_i = \text{AIC}_{c,i} - \text{AIC}_{c,\text{min}}`.)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_hyp</span>
<span class="sd">            Best hypothesis (``0`` for no step, ``1`` for step).</span>
<span class="sd">        rel_prob</span>
<span class="sd">            If H1 is the best hypothesis (and suffices ``maxdel``), its relative probability,</span>
<span class="sd">            otherwise the relative probability of H0 (which therefore can be ``0`` if H0 is also</span>
<span class="sd">            the best hypothesis in general).</span>
<span class="sd">        msr_hyps</span>
<span class="sd">            A 2-tuple of the two mean-squared residuals of the H0 and H1 hypotheses,</span>
<span class="sd">            respectively. Assuming the test is unbiased, this is the residual&#39;s variance.</span>
<span class="sd">            Is ``NaN`` in an element if the least-squares model did not converge.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        AIC_c : For more information about the AIC hypothesis test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do some checks</span>
        <span class="k">assert</span> <span class="n">xwindow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ywindow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> \
            <span class="s2">&quot;&#39;xwindow&#39; and &#39;ywindow&#39; have to have the same length in the first dimensions, &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">xwindow</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">ywindow</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">xwindow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> \
            <span class="s2">&quot;&#39;xwindow&#39; and &#39;ywindow&#39; must have an odd number of entries, &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">xwindow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="n">valid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ywindow</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ywindow</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">valid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> \
                <span class="s2">&quot;&#39;ywindow&#39; and &#39;valid&#39; have to have the same shape, &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">ywindow</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">valid</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="c1"># get number of valid observations</span>
        <span class="n">i_mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">xwindow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">n_pre</span> <span class="o">=</span> <span class="n">valid</span><span class="p">[:</span><span class="n">i_mid</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_post</span> <span class="o">=</span> <span class="n">valid</span><span class="p">[</span><span class="n">i_mid</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_total</span> <span class="o">=</span> <span class="n">n_pre</span> <span class="o">+</span> <span class="n">n_post</span>
        <span class="c1"># return with 0, 0 if we will not be able to get an estimate because of not enough data</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n_pre</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n_post</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">xfinite</span> <span class="o">=</span> <span class="n">xwindow</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">yfinite</span> <span class="o">=</span> <span class="n">ywindow</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="c1"># build mapping matrix for model H1</span>
        <span class="n">G1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_total</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># first column is mean</span>
        <span class="n">G1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># second column is slope</span>
        <span class="n">G1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfinite</span> <span class="o">-</span> <span class="n">xfinite</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># third column is the additional step</span>
        <span class="n">G1</span><span class="p">[</span><span class="n">n_pre</span><span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># without the step it&#39;s just the first two columns</span>
        <span class="n">G0</span> <span class="o">=</span> <span class="n">G1</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># fit for H1 first</span>
        <span class="c1"># (since if that one doesn&#39;t converge, we have to go with H0 anyway)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rss1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">yfinite</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># now we can fit for H0, and again just go with that if there is no solution</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rss0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">G0</span><span class="p">,</span> <span class="n">yfinite</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">rss1</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">)</span>
        <span class="c1"># now that both models produce results, let&#39;s get the AIC_c values</span>
        <span class="c1"># we&#39;ll again return the H0 if not both models have a valid AIC_c value</span>
        <span class="n">aic</span> <span class="o">=</span> <span class="p">[</span><span class="n">StepDetector</span><span class="o">.</span><span class="n">AIC_c</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="n">n_total</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span>
               <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">aic</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">rss0</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">,</span> <span class="n">rss1</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">)</span>
        <span class="c1"># let&#39;s check the difference between the two as a measure of evidence</span>
        <span class="n">best_hyp</span> <span class="o">=</span> <span class="n">aic</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">aic</span><span class="p">))</span>
        <span class="n">Delta_best</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="n">aic</span><span class="p">[</span><span class="n">best_hyp</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aic</span><span class="p">]</span>
        <span class="c1"># we will only recommend H1 if it has the both the minimum AIC_c, and</span>
        <span class="c1"># the difference to H0 is larger than maxdel</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">best_hyp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Delta_best</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxdel</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Delta_best</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">rss0</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">,</span> <span class="n">rss1</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Delta_best</span><span class="p">[</span><span class="n">best_hyp</span><span class="p">],</span> <span class="p">(</span><span class="n">rss0</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">,</span> <span class="n">rss1</span> <span class="o">/</span> <span class="n">n_total</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_search</span><span class="p">(</span><span class="n">data_and_params</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parallelizable part of the search, search_network and search_catalog methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_and_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_size_min</span><span class="p">,</span> <span class="n">maxdel</span> <span class="o">=</span> <span class="n">data_and_params</span>
            <span class="n">check_only</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_and_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="c1"># added the optional fifth parameter of which indices of x to check</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_size_min</span><span class="p">,</span> <span class="n">maxdel</span><span class="p">,</span> <span class="n">check_only</span> <span class="o">=</span> <span class="n">data_and_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Passed invalid &#39;data_and_params&#39; argument: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">data_and_params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># some checks</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;&#39;x&#39; and &#39;y&#39; need to be NumPy arrays, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="n">check_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">check_only</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">check_only</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">check_only</span><span class="p">])),</span> \
                <span class="sa">f</span><span class="s2">&quot;Invalid &#39;check_only&#39; parameter: </span><span class="si">{</span><span class="n">check_only</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="c1"># get sizes</span>
        <span class="n">num_observations</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_observations</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num_components</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># backwards-compatible check for empty list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">check_only</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_only</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># no indices to check, for backwards compatibility return empty arrays</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_components</span><span class="p">),</span> \
                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_components</span><span class="p">),</span> \
                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_components</span><span class="p">)</span>
        <span class="c1"># get valid array</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># make output arrays</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_observations</span><span class="p">,</span> <span class="n">num_components</span><span class="p">))</span>
        <span class="n">probs</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">var0</span><span class="p">,</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">probs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># loop over all columns</span>
        <span class="k">for</span> <span class="n">icomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_components</span><span class="p">):</span>
            <span class="c1"># loop through all rows, starting with a shrunken kernel at the edges</span>
            <span class="c1"># Beginning region</span>
            <span class="n">halfwindow</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kernel_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">check_only</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">check_only</span><span class="p">))</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">halfwindow</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">kernel_size_min</span><span class="p">):</span>
                    <span class="n">halfwindow</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="n">hyp</span><span class="p">,</span> <span class="n">Del</span><span class="p">,</span> <span class="p">(</span><span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span><span class="p">)</span> <span class="o">=</span> \
                    <span class="n">StepDetector</span><span class="o">.</span><span class="n">test_single</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                             <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span>
                                             <span class="n">valid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span>
                                             <span class="n">maxdel</span><span class="o">=</span><span class="n">maxdel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hyp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Del</span>
                <span class="n">var0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span> <span class="n">var1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span>
                <span class="n">halfwindow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Middle region</span>
            <span class="k">assert</span> <span class="n">halfwindow</span> <span class="o">==</span> <span class="n">kernel_size</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">range_main</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">halfwindow</span><span class="p">,</span> <span class="n">num_observations</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_only</span><span class="p">:</span>
                <span class="n">range_main</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range_main</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">check_only</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range_main</span><span class="p">:</span>
                <span class="n">hyp</span><span class="p">,</span> <span class="n">Del</span><span class="p">,</span> <span class="p">(</span><span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span><span class="p">)</span> <span class="o">=</span> \
                    <span class="n">StepDetector</span><span class="o">.</span><span class="n">test_single</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                             <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span>
                                             <span class="n">valid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span>
                                             <span class="n">maxdel</span><span class="o">=</span><span class="n">maxdel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hyp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Del</span>
                <span class="n">var0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span> <span class="n">var1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span>
            <span class="c1"># Ending region</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_observations</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">,</span> <span class="n">num_observations</span><span class="p">):</span>
                <span class="n">halfwindow</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">check_only</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">check_only</span><span class="p">))</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">halfwindow</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">kernel_size_min</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">hyp</span><span class="p">,</span> <span class="n">Del</span><span class="p">,</span> <span class="p">(</span><span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span><span class="p">)</span> <span class="o">=</span> \
                    <span class="n">StepDetector</span><span class="o">.</span><span class="n">test_single</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                             <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span>
                                             <span class="n">valid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">halfwindow</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">halfwindow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span>
                                             <span class="n">maxdel</span><span class="o">=</span><span class="n">maxdel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hyp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Del</span>
                <span class="n">var0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">],</span> <span class="n">var1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="n">rss0</span><span class="p">,</span> <span class="n">rss1</span>
        <span class="c1"># return</span>
        <span class="k">if</span> <span class="n">check_only</span><span class="p">:</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="n">check_only</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_components</span><span class="p">)</span>
            <span class="n">var0</span> <span class="o">=</span> <span class="n">var0</span><span class="p">[</span><span class="n">check_only</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_components</span><span class="p">)</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">var1</span><span class="p">[</span><span class="n">check_only</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_components</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">probs</span><span class="p">,</span> <span class="n">var0</span><span class="p">,</span> <span class="n">var1</span>

<div class="viewcode-block" id="StepDetector.search">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector.search">[docs]</a>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">maxdel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will search for steps in the data.</span>
<span class="sd">        Upon successful completion, it will return the relative step probabilities</span>
<span class="sd">        as well as the residuals variances of the two hypotheses tested</span>
<span class="sd">        (as reported by :meth:`~test_single`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x</span>
<span class="sd">            Input array of shape :math:`(\text{num_observations},)`.</span>
<span class="sd">            Should not contain NaNs.</span>
<span class="sd">        y</span>
<span class="sd">            Input array of shape :math:`(\text{num_observations}, \text{num_components})`.</span>
<span class="sd">            Can contain NaNs.</span>
<span class="sd">        maxdel</span>
<span class="sd">            Difference in AIC that should be considered not significantly better.</span>
<span class="sd">            (Refers to :math:`\Delta_i = \text{AIC}_{c,i} - \text{AIC}_{c,\text{min}}`.)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        probabilities</span>
<span class="sd">            Contains the relative probabilities array.</span>
<span class="sd">            Has shape :math:`(\text{num_observations}, \text{num_components})`.</span>
<span class="sd">        var0</span>
<span class="sd">            Contains the array of the residuals variance of the hypothesis</span>
<span class="sd">            that no step is present.</span>
<span class="sd">            Has shape :math:`(\text{num_observations}, \text{num_components})`.</span>
<span class="sd">        var1</span>
<span class="sd">            Contains the array of the residuals variance of the hypothesis</span>
<span class="sd">            that a step is present.</span>
<span class="sd">            Has shape :math:`(\text{num_observations}, \text{num_components})`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`~test_single` : For more explanations about the return values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># call individual search function and store result</span>
        <span class="k">return</span> <span class="n">StepDetector</span><span class="o">.</span><span class="n">_search</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size_min</span><span class="p">,</span> <span class="n">maxdel</span><span class="p">))</span></div>


<div class="viewcode-block" id="StepDetector.search_network">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector.search_network">[docs]</a>
    <span class="k">def</span> <span class="nf">search_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">net</span><span class="p">:</span> <span class="n">Network</span><span class="p">,</span>
                       <span class="n">ts_description</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">maxdel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
                       <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">,</span>
                       <span class="n">gap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
                       <span class="n">gap_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span>
                       <span class="n">aggregate_components</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">no_pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that searches for steps in an entire network (possibly in parallel),</span>
<span class="sd">        thresholds those probabilities, and identifies all the consecutive ranges in which</span>
<span class="sd">        steps happen over the network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        net</span>
<span class="sd">            Network instance to operate on.</span>
<span class="sd">        ts_description</span>
<span class="sd">            :class:`~disstans.timeseries.Timeseries` description that will be analyzed.</span>
<span class="sd">        maxdel</span>
<span class="sd">            Difference in AIC that should be considered not significantly better.</span>
<span class="sd">            (Refers to :math:`\Delta_i = \text{AIC}_{c,i} - \text{AIC}_{c,\text{min}}`.)</span>
<span class="sd">        threshold</span>
<span class="sd">            Minimum :math:`\Delta_i \geq 0` that needs to be satisfied in order to be a step.</span>
<span class="sd">        gap</span>
<span class="sd">            Maximum gap between identified steps to count as a continuous period</span>
<span class="sd">            of possible steps.</span>
<span class="sd">        gap_unit</span>
<span class="sd">            Time unit of ``gap``.</span>
<span class="sd">        aggregate_components</span>
<span class="sd">            If ``True``, use the maximum step probability across all data components</span>
<span class="sd">            when searching for steps. Otherwise, keep all steps from maximum probabilities in</span>
<span class="sd">            each component (which could lead to multiple close-by steps).</span>
<span class="sd">        no_pbar</span>
<span class="sd">            Suppress the progress bar with ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        step_table</span>
<span class="sd">            A DataFrame containing the columns ``&#39;station&#39;`` (its name), ``&#39;time&#39;``</span>
<span class="sd">            (a timestamp of the station) and ``&#39;probability&#39;`` (maximum :math:`\Delta_i`</span>
<span class="sd">            over all components for this timestamp), as well as ``var0``, ``var1``</span>
<span class="sd">            (the two hypotheses&#39; residuals variances for the component of</span>
<span class="sd">            maximum step probability) and ``varred`` (the variance reduction in percent,</span>
<span class="sd">            ``(var0 - var1) / var0``).</span>
<span class="sd">        step_ranges</span>
<span class="sd">            A list of lists containing continuous periods over all stations of the potential</span>
<span class="sd">            steps as determined by ``gap`` and ``gap_unit``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the stations who have this timeseries</span>
        <span class="n">valid_stations</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">station</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">ts_description</span> <span class="ow">in</span> <span class="n">station</span><span class="o">.</span><span class="n">timeseries</span><span class="p">}</span>
        <span class="c1"># early exit if no station containing that timeseries was found</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_stations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No station containing timeseries &#39;</span><span class="si">{</span><span class="n">ts_description</span><span class="si">}</span><span class="s2">&#39; found.&quot;</span><span class="p">,</span>
                 <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">,</span>
                                         <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">,</span> <span class="s2">&quot;varred&quot;</span><span class="p">]),</span> <span class="p">[]</span>
        <span class="c1"># make a list that will contain all individual result DataFrames</span>
        <span class="n">step_tables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># run parallelized StepDetector._search</span>
        <span class="n">iterable_input</span> <span class="o">=</span> <span class="p">((</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">station</span><span class="p">[</span><span class="n">ts_description</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">),</span>
                           <span class="n">station</span><span class="p">[</span><span class="n">ts_description</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size_min</span><span class="p">,</span> <span class="n">maxdel</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">valid_stations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">var0</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span> <span class="ow">in</span> \
            <span class="nb">zip</span><span class="p">(</span><span class="n">valid_stations</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">valid_stations</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                <span class="n">tqdm</span><span class="p">(</span><span class="n">parallelize</span><span class="p">(</span><span class="n">StepDetector</span><span class="o">.</span><span class="n">_search</span><span class="p">,</span> <span class="n">iterable_input</span><span class="p">),</span>
                     <span class="n">ascii</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_stations</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span>
                     <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Searching for steps&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">no_pbar</span><span class="p">)):</span>
            <span class="c1"># find steps given the just calculated probabilities</span>
            <span class="c1"># setting the maximum number of steps to infinite to not miss anything</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">StepDetector</span><span class="o">.</span><span class="n">steps</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">maxsteps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                       <span class="n">aggregate_components</span><span class="o">=</span><span class="n">aggregate_components</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># combine all data components and keep largest probability if the step</span>
            <span class="c1"># is present in multiple components</span>
            <span class="n">unique_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">steps</span><span class="p">)))</span>
            <span class="n">stepprobs</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="n">unique_steps</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">stepsvar0</span><span class="p">,</span> <span class="n">stepsvar1</span> <span class="o">=</span> <span class="n">var0</span><span class="p">[</span><span class="n">unique_steps</span><span class="p">,</span> <span class="p">:],</span> <span class="n">var1</span><span class="p">[</span><span class="n">unique_steps</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">maxprobindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">stepprobs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">maxstepprobs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">stepprobs</span><span class="p">,</span> <span class="n">maxprobindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">maxstepvar0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">stepsvar0</span><span class="p">,</span> <span class="n">maxprobindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">maxstepvar1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">stepsvar1</span><span class="p">,</span> <span class="n">maxprobindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># isolate the actual timestamps and add to the list of DataFrames</span>
            <span class="n">steptimes</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="n">ts_description</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">unique_steps</span><span class="p">]</span>
            <span class="n">step_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">steptimes</span><span class="p">),</span>
                                             <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">steptimes</span><span class="p">,</span>
                                             <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="n">maxstepprobs</span><span class="p">,</span>
                                             <span class="s2">&quot;var0&quot;</span><span class="p">:</span> <span class="n">maxstepvar0</span><span class="p">,</span>
                                             <span class="s2">&quot;var1&quot;</span><span class="p">:</span> <span class="n">maxstepvar1</span><span class="p">}))</span>
            <span class="c1"># this code could be used to create a model object and assign it to the station</span>
            <span class="c1"># mdl = disstans.models.Step(steptimes)</span>
            <span class="c1"># station.add_local_model(ts_description, &quot;Detections&quot;, mdl)</span>
        <span class="c1"># return early if no steps were found</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_tables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">,</span>
                                         <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">,</span> <span class="s2">&quot;varred&quot;</span><span class="p">]),</span> <span class="p">[]</span>
        <span class="c1"># combine individual DataFrames to one</span>
        <span class="n">step_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">step_tables</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># sort dataframe by probability</span>
        <span class="n">step_table</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># get coefficient of partial determination, i.e. how much the variance is reduced</span>
        <span class="c1"># (in percent) by including a step</span>
        <span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;varred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;var0&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;var1&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;var0&quot;</span><span class="p">]</span>
        <span class="c1"># get the consecutive steptime ranges</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">step_table</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">unique_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">unique_steps</span><span class="p">)</span> <span class="o">/</span> <span class="n">Timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gap_unit</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">step_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_steps</span><span class="p">[</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step_ranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">step_table</span><span class="p">,</span> <span class="n">step_ranges</span></div>


<div class="viewcode-block" id="StepDetector.search_catalog">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector.search_catalog">[docs]</a>
    <span class="k">def</span> <span class="nf">search_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">net</span><span class="p">:</span> <span class="n">Network</span><span class="p">,</span>
                       <span class="n">ts_description</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">catalog</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Dataframe</span><span class="p">,</span>
                       <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">gap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
                       <span class="n">gap_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span>
                       <span class="n">keep_nan_probs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">no_pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search a dictionary of potential step times for each station in the dictionary</span>
<span class="sd">        and assess the probability for each one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        net</span>
<span class="sd">            Network instance to operate on.</span>
<span class="sd">        ts_description</span>
<span class="sd">            :class:`~disstans.timeseries.Timeseries` description that will be analyzed.</span>
<span class="sd">        catalog</span>
<span class="sd">            Dictionary where each key is a station name and its value is a list of</span>
<span class="sd">            :class:`~pandas.Timestamp` compatible potential times/dates.</span>
<span class="sd">            Alternatively, a DataFrame with at least the columns ``&#39;station&#39;`` and ``&#39;time&#39;``.</span>
<span class="sd">        threshold</span>
<span class="sd">            Minimum :math:`\Delta_i \geq 0` that needs to be satisfied in order to be a step.</span>
<span class="sd">        gap</span>
<span class="sd">            Maximum gap between identified steps to count as a continuous period</span>
<span class="sd">            of possible steps.</span>
<span class="sd">        gap_unit</span>
<span class="sd">            Time unit of ``gap``.</span>
<span class="sd">        keep_nan_probs</span>
<span class="sd">            (Only applies to a DataFrame-type ``catalog`` input.)</span>
<span class="sd">            If a catalogued station is not in the network, or if a catalogued timestamp</span>
<span class="sd">            is after the available timeseries, no step probability can be calculated</span>
<span class="sd">            and the results will contain NaNs.</span>
<span class="sd">            If ``True``, those entries will be kept in the output, and if ``False``,</span>
<span class="sd">            they will be dropped.</span>
<span class="sd">        no_pbar</span>
<span class="sd">            Suppress the progress bar with ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        step_table</span>
<span class="sd">            A DataFrame containing the columns ``&#39;station&#39;`` (its name), ``&#39;time&#39;``</span>
<span class="sd">            (a timestamp of the station) and ``&#39;probability&#39;`` (maximum :math:`\Delta_i`</span>
<span class="sd">            over all components for this timestamp) for each potential step in ``catalog``,</span>
<span class="sd">            as well as ``var0`` and ``var1`` (the two hypotheses&#39; residuals variances</span>
<span class="sd">            for the component of maximum step probability).</span>
<span class="sd">            If a DataFrame was passed as ``catalog``, a copy of that will be returned, with</span>
<span class="sd">            the added columns specified above.</span>
<span class="sd">        step_ranges</span>
<span class="sd">            A list of lists containing continuous periods over all stations of the potential</span>
<span class="sd">            steps as determined by ``gap`` and ``gap_unit``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># hard-code maxdel to not filter out any item since we are asking about specific times</span>
        <span class="n">maxdel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># get a simple dictionary representation if catalog was passed as dictionary</span>
        <span class="c1"># and set keep_nan_probs if not specified</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">catalog</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">col</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]]),</span> \
                <span class="s2">&quot;Invalid input &#39;catalog&#39; DataFrame columns.&quot;</span>
            <span class="n">catalog_df</span> <span class="o">=</span> <span class="n">catalog</span>
            <span class="n">catalog</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">catalog_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">)[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
            <span class="n">augment_df</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">out_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">catalog_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">,</span> <span class="s2">&quot;varred&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">catalog</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> \
                <span class="s2">&quot;&#39;catalog&#39; must be either a dictionary or DataFrame.&quot;</span>
            <span class="n">augment_df</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">,</span> <span class="s2">&quot;varred&quot;</span><span class="p">]</span>
        <span class="c1"># for each station, find the first time index after a catalogued event</span>
        <span class="c1"># (alternatively, we could &quot;add&quot; a timestamp without an observation if</span>
        <span class="c1"># there isn&#39;t a timestamp already present - probably better, but harder)</span>
        <span class="n">check_indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># we also need to keep track of the originally requested time (for the output)</span>
        <span class="n">catalog_timeexists</span> <span class="o">=</span> <span class="p">{</span><span class="n">sta_name</span><span class="p">:</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">steptimes</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">sta_name</span><span class="p">,</span> <span class="n">steptimes</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># check if there is at least one station with the desired timeseries</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">ts_description</span> <span class="ow">in</span> <span class="n">net</span><span class="p">[</span><span class="n">sta_name</span><span class="p">]</span><span class="o">.</span><span class="n">timeseries</span>
                <span class="k">for</span> <span class="n">sta_name</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sta_name</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No station containing timeseries &#39;</span><span class="si">{</span><span class="n">ts_description</span><span class="si">}</span><span class="s2">&#39; found.&quot;</span><span class="p">,</span>
                 <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">out_cols</span><span class="p">),</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sta_name</span><span class="p">,</span> <span class="n">steptimes</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># skip if station or timeseries not present</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sta_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">ts_description</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">net</span><span class="p">[</span><span class="n">sta_name</span><span class="p">]</span><span class="o">.</span><span class="n">timeseries</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">check_indices</span><span class="p">[</span><span class="n">sta_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ist</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">steptimes</span><span class="p">):</span>
                <span class="n">index_after</span> <span class="o">=</span> <span class="p">(</span><span class="n">net</span><span class="p">[</span><span class="n">sta_name</span><span class="p">][</span><span class="n">ts_description</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">check_indices</span><span class="p">[</span><span class="n">sta_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_after</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># catalogued time is after the last timestamp</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">catalog_timeexists</span><span class="p">[</span><span class="n">sta_name</span><span class="p">][</span><span class="n">ist</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># return early if we found stations, but no timesteps to check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">any</span><span class="p">(</span><span class="n">catalog_timeexists</span><span class="p">[</span><span class="n">sta_name</span><span class="p">])</span> <span class="k">for</span> <span class="n">sta_name</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">out_cols</span><span class="p">),</span> <span class="p">[]</span>
        <span class="c1"># make a list that will contain all individual result DataFrames</span>
        <span class="n">step_tables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># run parallelized StepDetector._search</span>
        <span class="n">stations_overlap</span> <span class="o">=</span> <span class="p">[</span><span class="n">sta_name</span> <span class="k">for</span> <span class="n">sta_name</span><span class="p">,</span> <span class="n">chkix</span> <span class="ow">in</span> <span class="n">check_indices</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chkix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">iterable_input</span> <span class="o">=</span> <span class="p">((</span><span class="n">tvec_to_numpycol</span><span class="p">(</span><span class="n">net</span><span class="p">[</span><span class="n">sta_name</span><span class="p">][</span><span class="n">ts_description</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">),</span>
                           <span class="n">net</span><span class="p">[</span><span class="n">sta_name</span><span class="p">][</span><span class="n">ts_description</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size_min</span><span class="p">,</span>
                           <span class="n">maxdel</span><span class="p">,</span> <span class="n">check_indices</span><span class="p">[</span><span class="n">sta_name</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">sta_name</span> <span class="ow">in</span> <span class="n">stations_overlap</span><span class="p">)</span>
        <span class="n">results_iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">parallelize</span><span class="p">(</span><span class="n">StepDetector</span><span class="o">.</span><span class="n">_search</span><span class="p">,</span> <span class="n">iterable_input</span><span class="p">),</span>
                                <span class="n">ascii</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">stations_overlap</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;station&quot;</span><span class="p">,</span>
                                <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Searching for steps&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">no_pbar</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">var0</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stations_overlap</span><span class="p">,</span> <span class="n">results_iterator</span><span class="p">):</span>
            <span class="c1"># probs now contains a row for each catalog item</span>
            <span class="c1"># if the probability is NaN, AIC does not see evidence for a step,</span>
            <span class="c1"># if it is a float, then that&#39;s the likelihood of a step (always positive)</span>
            <span class="c1"># var0 and var1 can contain values regardless of the entry in probs</span>
            <span class="n">has_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">probs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">has_steps</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># build matrix with maximum step probabilities for all identified steps</span>
            <span class="n">maxprobindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">has_steps</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">maxstepprobs</span><span class="p">,</span> <span class="n">maxstepvar0</span><span class="p">,</span> <span class="n">maxstepvar1</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">has_steps</span><span class="p">,</span> <span class="p">:],</span> <span class="n">maxprobindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">var0</span><span class="p">[</span><span class="n">has_steps</span><span class="p">,</span> <span class="p">:],</span> <span class="n">maxprobindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">var1</span><span class="p">[</span><span class="n">has_steps</span><span class="p">,</span> <span class="p">:],</span> <span class="n">maxprobindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># isolate the original timestamps and add to the list of DataFrames</span>
            <span class="n">steptimes</span> <span class="o">=</span> <span class="p">[</span><span class="n">origtime</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">origtime</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">catalog</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                         <span class="k">if</span> <span class="n">catalog_timeexists</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">has_steps</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">step_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">steptimes</span><span class="p">),</span>
                                             <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">steptimes</span><span class="p">,</span>
                                             <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="n">maxstepprobs</span><span class="p">,</span>
                                             <span class="s2">&quot;var0&quot;</span><span class="p">:</span> <span class="n">maxstepvar0</span><span class="p">,</span>
                                             <span class="s2">&quot;var1&quot;</span><span class="p">:</span> <span class="n">maxstepvar1</span><span class="p">}))</span>
        <span class="c1"># return early if no steps were found</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_tables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">out_cols</span><span class="p">),</span> <span class="p">[]</span>
        <span class="c1"># combine individual DataFrames to one</span>
        <span class="n">step_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">step_tables</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># merge it with the input dataframe, if provided</span>
        <span class="k">if</span> <span class="n">augment_df</span><span class="p">:</span>
            <span class="n">catalog_df</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">catalog_df</span><span class="p">[</span><span class="s2">&quot;var0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">catalog_df</span><span class="p">[</span><span class="s2">&quot;var1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">step_table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">row_location</span> <span class="o">=</span> <span class="p">(</span><span class="n">catalog_df</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">])</span> <span class="o">&amp;</span> \
                               <span class="p">(</span><span class="n">catalog_df</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
                <span class="n">catalog_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row_location</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">]]</span> <span class="o">=</span> \
                    <span class="n">row</span><span class="p">[[</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_nan_probs</span><span class="p">:</span>
                <span class="n">catalog_df</span> <span class="o">=</span> <span class="n">catalog_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;var0&quot;</span><span class="p">,</span> <span class="s2">&quot;var1&quot;</span><span class="p">])</span>
            <span class="n">step_table</span> <span class="o">=</span> <span class="n">catalog_df</span>
        <span class="c1"># sort</span>
        <span class="n">step_table</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># get coefficient of partial determination, i.e. how much the variance is reduced</span>
        <span class="c1"># (in percent) by including a step</span>
        <span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;varred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;var0&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;var1&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;var0&quot;</span><span class="p">]</span>
        <span class="c1"># get the consecutive steptime ranges</span>
        <span class="n">unique_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">step_table</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">unique_steps</span><span class="p">)</span> <span class="o">/</span> <span class="n">Timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gap_unit</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">step_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_steps</span><span class="p">[</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">step_table</span><span class="p">,</span> <span class="n">step_ranges</span></div>


<div class="viewcode-block" id="StepDetector.steps">
<a class="viewcode-back" href="../../disstans/processing.html#disstans.processing.StepDetector.steps">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">steps</span><span class="p">(</span><span class="n">probabilities</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
              <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
              <span class="n">maxsteps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
              <span class="n">aggregate_components</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
              <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
              <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Threshold the probabilities to return a list of steps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        probabilities</span>
<span class="sd">            Array of probabilities.</span>
<span class="sd">        threshold</span>
<span class="sd">            Minimum :math:`\Delta_i \geq 0` that needs to be satisfied in order to be a step.</span>
<span class="sd">        maxsteps</span>
<span class="sd">            Return at most ``maxsteps`` number of steps. Can be useful if a good value for</span>
<span class="sd">            ``threshold`` has not been found yet.</span>
<span class="sd">        aggregate_components</span>
<span class="sd">            If ``True``, use the maximum step probability across all data components when</span>
<span class="sd">            searching for steps. Otherwise, keep all steps from maximum probabilities in</span>
<span class="sd">            each component (which could lead to multiple close-by steps).</span>
<span class="sd">        verbose</span>
<span class="sd">            If ``True``, print warnings when there will be a large number of steps</span>
<span class="sd">            identified given the ``threshold``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Returns a list of :class:`~numpy.ndarray` arrays that contain the indices of steps</span>
<span class="sd">            for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize</span>
        <span class="n">probabilities</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">aggregate_components</span><span class="p">:</span>
            <span class="n">probabilities</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">icomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># find peaks above the threshold</span>
            <span class="n">peaks</span><span class="p">,</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">probabilities</span><span class="p">[:,</span> <span class="n">icomp</span><span class="p">],</span> <span class="n">height</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
            <span class="c1"># if maxsteps is set, reduce steps to that number</span>
            <span class="k">if</span> <span class="n">peaks</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">maxsteps</span><span class="p">:</span>
                <span class="n">largest_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;peak_heights&quot;</span><span class="p">],</span> <span class="o">-</span><span class="n">maxsteps</span><span class="p">)[</span><span class="o">-</span><span class="n">maxsteps</span><span class="p">:]</span>
                <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">largest_ix</span><span class="p">]</span>
                <span class="c1"># warn about the new effective threshold</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In order to return at most </span><span class="si">{</span><span class="n">maxsteps</span><span class="si">}</span><span class="s2"> steps, the threshold has &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;been increased to </span><span class="si">{</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;peak_heights&#39;</span><span class="p">][</span><span class="n">largest_ix</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="c1"># warn if a large number of steps have been detected</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In component </span><span class="si">{</span><span class="n">icomp</span><span class="si">}</span><span class="s2">, using threshold=</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2"> leads to &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">peaks</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2%</span><span class="si">}</span><span class="s2"> of timestamps being &quot;</span>
                              <span class="s2">&quot;steps. Consider setting a higher threshold.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">steps</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Tobias Köhne.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>